{"version":3,"file":"BunnyIsland.html","sources":["BunnyIsland.c","GL_utilities.c","loadobj.c","BI_draw.c","BI_terrain.c","BI_physics.c","BI_objects/BI_player.c","BI_objects/BI_bunny.c","BI_objects/BI_arrow.c","BI_objects/BI_lightpost.c","BI_objects/BI_orc.c","BI_objects/BI_grenbox.c","LoadTGA2.c","VectorUtils2.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;;;;;;;;;;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;;AAEA;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;;;;;;;;;;;AAGA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAMA;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AACA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;;AACA;AACA;;AACA;;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AACA;AAEA;;AACA;AAAA;AAAA;;AACA;AAEA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;AACA;;;;;;;;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AAFA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AAFA;AAAA;AAAA;AAAA;;AAGA;AAAA;AACA;AAAA;AAGA;AACA;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AADA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AA6BA;AACA;AACA;AAOA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;AACA;AAAA;AACA;AAAA;AAAA;AAUA;AAAA;AAAA;;AAEA;AAEA;;AACA;AAAA;AAAA;;AAEA;AAEA;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AAEA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;;AALA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AARA;AAAA;AAAA;AAAA;;AASA;;AAEA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;;AACA;;AAPA;AAAA;AAAA;AAAA;;AAQA;AAAA;AACA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;ACtdA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AAKA;AACA;AAGA;AAAA;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AACA;;;;;;;;;;;;;;;;;;;AAIA;AACA;AAGA;AAAA;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AACA;;;;;;;;;;;;;;;;;;AAOA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;AAUA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;AAkBA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC8WA;AAAA;AAKA;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AAGA;AAAA;AAAA;;;AAEA;;AAXA;AAAA;AAAA;AAAA;;AAaA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AACA;;AAGA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;;;;AAEA;;AAlCA;AAAA;AAAA;AAAA;;AAoCA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;;AACA;;;;;;;;;;;;;;;;;;AA4NA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAUA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;;;;;;;;;;;;;;;;;AA5cA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;;AAEA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+FA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AA5DA;AAAA;AAAA;AAAA;;AA8DA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAbA;AAAA;AAAA;AAAA;;AAcA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAkBA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAGA;AAGA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAEA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;;;;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AA1CA;AAAA;AAAA;AAAA;;AA4CA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;;AACA;;AAtBA;AAAA;AAAA;AAAA;;AAwBA;AAAA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;;AApZA;AACA;;AAAA;AAAA;AAAA;;AAEA;AACA;;;AAGA;AAAA;AACA;;AAEA;AAAA;AACA;;AAEA;AAAA;AACA;;AAEA;AAAA;AACA;;AAGA;;AAEA;;AAEA;AAGA;;AAEA;;AACA;;;;;;;;;;;;;;AApOA;AAEA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;;;;;;;;;;;;;;;;;AA2FA;AAGA;;AAEA;AAEA;;;AAIA;AAAA;AAAA;;AAEA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;AACA;;AACA;;AAIA;AAAA;AAAA;;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;AACA;;AACA;AAAA;AAAA;;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;AACA;;AACA;AAAA;AAAA;;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;AACA;;AACA;AACA;;AAGA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AAEA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAlJA;AAAA;AAGA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;;AACA;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;;AACA;;;;;;;;;;;;;;;;;;;AA5EA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;;AACA;;;;;;;;;;;;;;;;;;;AAzJA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAEA;;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAGA;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAEA;AACA;AACA;;AAGA;AAAA;AACA;AAAA;;;AAEA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAEA;AACA;AACA;;AAGA;AAAA;AACA;AAAA;;;AAEA;AAAA;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;;AAGA;AACA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAEA;AAAA;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;ACvGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAKA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AANA;AAAA;AAAA;AAAA;;AAUA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AACA;AAAA;AACA;AACA;;AAGA;AACA;AACA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AACA;;;;;;;;;;;;;;;;AAIA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAGA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAGA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AAIA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;;;;;;;;;;AAGA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;AAyBA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AAGA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAIA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1aA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AAGA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AAEA;;AAIA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAdA;AAAA;AAAA;AAAA;;AAcA;;AAfA;AAAA;AAAA;AAAA;;AAgBA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AA9EA;AAAA;AAAA;AAAA;;AA8EA;;AA/EA;AAAA;AAAA;AAAA;;AAiFA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAbA;AAAA;AAAA;AAAA;;AAoBA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;AClQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;ACKA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;AC/BA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AACA;;AACA;;AAIA;AACA;AAIA;AAAA;;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;;AACA;;AAEA;;AAjBA;AAAA;AAAA;AAAA;;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;AC1FA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;;;;;;;;;;;;;;;;;;ACvCA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;ACAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;;;;;;;;;;;;;;;ACzEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClCA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;;AAEA;;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AACA;AAAA;;AAGA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;AAEA;;AAVA;AAAA;AAAA;AAAA;;AAWA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AALA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAGA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;;;AACA;;;;;;;;;;;;;;;;;;;ACnKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AA0CA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;AAeA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;;AAVA;AAAA;AAAA;AAAA;;AAUA;;AAXA;AAAA;AAAA;AAAA;;AAYA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;;AAiMA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAFA;AAAA;AAAA;AAAA;;AAGA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA","sourcesContent":["#include \"GL_utilities.h\"\n#include \"loadobj.h\"\n#include \"stdio.h\"\n#include \"string.h\"\n#include \"math.h\"\n#include \"VectorUtils2.h\"\n#include \"stdlib.h\"\n#include \"BI_draw.h\"\n#include \"BI_physics.h\"\n#include \"ctype.h\"\n#include \"BI_objects/BI_player.h\"\n#include \"BI_objects/BI_grenbox.h\"\n#include \"BI_objects/BI_bunny.h\"\n#include \"BI_objects/BI_lightpost.h\"\n#include \"BI_objects/BI_arrow.h\"\n#include \"BI_objects/BI_orc.h\"\n#include \"BunnyIsland.h\"\n#include <time.h>\n\n\n// Globals\nconst int WIDTH = 1024;\nconst int HEIGHT = 768;\n\n\nint numFrames=0, timeSinceLastFpsCheck=0, toggle = 1;\nint mouseX=(1024/2),mouseY=(768/2);\nint activeLightsources = 1;\n\nint keyStates[257], fps=0, gameOver = 0, reflections = 0; \nfloat closestGrenboxDist = 0.0f, tempdist;\n;\nGLfloat angleY = 0.0f;\nGLfloat angleX = 0.0f;\n#define startposX 721.0\n#define startposZ 318.0\nGLfloat temp_x, temp_y, temp_z, speed=0.5f;\n\n\tGLfloat lookAtMatrix[9] = {startposX,20.0,startposZ, //Position camera\n\t\t\t\tstartposX,20.0,-startposZ,\t//where to look\n\t\t\t\t0.0f,1.0f,0.0f}; // Up\n\nGLfloat cameraMatrix[16] = {    1.0f, 0.0f, 0.0f, 0.0f,\n                        0.0f, 1.0f, 0.0f, 0.0f, \n                        0.0f, 0.0f, 1.0f, 0.0f,\n                        0.0f, 0.0f, 0.0f, 1.0f };\n\nLightpost *lpArray[numLightsources];\n\nGLuint tid = 0;\nGLuint ticktid = 0;\n\nBunny *bunnyArray[numBunnies];\nGrenbox *grenboxArray[100];\nPlayer *player;\nOrc *orc;\n\nArrow *arrow;\n\n/// GAME LOGIC VAR/CONST\n#define NEXTLVLLIMIT 30\nint grenades = 1;\nint level = 1;\nint castlehp = 30;\n//END GAME LOGIC VAR/CONST\nvoid lookAt(GLfloat px, GLfloat py, GLfloat pz,\n                    GLfloat lx, GLfloat ly, GLfloat lz,\n                    GLfloat vx, GLfloat vy, GLfloat vz,\n\t\t\t\t\tGLfloat *cm)\n{\n    Point3D p, l, n, v, u;\n    \n\n    SetVector(px, py, pz, &p);\n    SetVector(lx, ly, lz, &l);\n    SetVector(vx, vy, vz, &v);\n\tVectorSub(&l,&p,&n);\n\tNormalize(&n);\n\tScalarMult(&n,-1.0f,&n);\n\tCrossProduct(&v,&n,&u);\n\tNormalize(&u);\t\n\tCrossProduct(&n,&u,&v);\n\tPoint3D uMinus, vMinus, nMinus;\n\tScalarMult(&u,-1.0f,&uMinus);\n\tScalarMult(&v,-1.0f,&vMinus);\n\tScalarMult(&n,-1.0f,&nMinus);\n\tcm[0] = u.x;\t\tcm[1] = u.y;\t\tcm[2] = u.z;\t \tcm[3] = DotProduct(&uMinus,&p);\n\tcm[4] = v.x;\t\tcm[5] = v.y;\t\tcm[6] = v.z;\t \tcm[7] = DotProduct(&vMinus,&p);\n\tcm[8] = n.x;\t\tcm[9] = n.y;\t\tcm[10] = n.z;\t\tcm[11] = DotProduct(&nMinus,&p);\n\tcm[12] = 0.0f;\t\tcm[13] = 0.0f;\t\tcm[14] = 0.0f;\t\tcm[15] = 1.0f;\n\n\n\n}\n\nvoid keyUpp (unsigned char key, int x, int y) {\n\ttoggle = 1;\n\tkeyStates[tolower(key)] = 0; // Set the state of the current key to not pressed  \n\tkeyStates[256] = 0;\n}  \n\nvoid keyPressed (unsigned char key, int x, int y) {  \n\tkeyStates[tolower(key)] = 1; // Set the state of the current key to pressed\n\tif (glutGetModifiers() & GLUT_ACTIVE_SHIFT) keyStates[256] = 1; \n\n}\nvoid mouseMove(int x, int y) {\n\tint deltaX =x-WIDTH/2;\n\tint\tdeltaY = y-HEIGHT/2;\n\tif( deltaX != 0 || deltaY != 0) {\n\t\tangleY += deltaX * 0.002f*speed;\n\t\tangleX += deltaY * 0.002f*speed;\n\n\t\tif(angleY>2*PI) angleY-=2*PI;\n\t\tif(angleY<-2*PI) angleY+=2*PI;\n\t\tplayer->ry = angleY;\n\n\t\tif(angleX>1.0) angleX = 1.0;\n\t\tif(angleX<-1.0) angleX = -1.0;\n\t\t\n\t\tlookAtMatrix[3] = lookAtMatrix[0] + sin(angleY);\n\t\tlookAtMatrix[5] = lookAtMatrix[2] - cos(angleY);\n\t\tlookAtMatrix[4] = lookAtMatrix[1] -\t angleX;\n\t\t//glutWarpPointer(WIDTH/2, HEIGHT/ 2); need workaround\n\t}\n\t\n}\nvoid fireArrow()\n{\n\tfree(arrow);\n\tfloat absAngleX;\n\tabsAngleX = (angleX<0) ? -angleX:angleX;\n\tarrow = CreateArrow(player->x, player->y, player->z, sin(angleY)*(1.1-absAngleX), -angleX*20, -cos(angleY)*(1.1-absAngleX), player->ry);\n\t//printf(\"dy:%f\\n\", (1-absAngleX));\n\n\n}\nvoid fireGrenade()\n{\n\tif(grenades<1) return;\n\tgrenades--;\n\tfor (int i=0;i<numBunnies;i++)\n\t{\n\t\tbunnyArray[i]->hp=0;\n\t}\n\n\n}\nvoid mouseClick(int button, int state, int x, int y)\n{\n\tif(button == GLUT_LEFT_BUTTON && state == GLUT_DOWN)\n{\n\tfireArrow();\n}\n\n\tif(button == GLUT_RIGHT_BUTTON && state == GLUT_DOWN)\n{\n\tfireGrenade();\n}\n\t\n}\n\n\nvoid keyOperations (void) {\n\n\nint strafed = 0, moved = 0;\n\n\t//Print Debug\n\tif (keyStates['p']) {\n\t\tprintf(\"x:%f y:%f z:%f \\n\", lookAtMatrix[0],lookAtMatrix[1],lookAtMatrix[2]);\n\t}\n\tif (keyStates['o'] && toggle) {\n\t\treflections = reflections ? 0:1;\n\t\ttoggle=0;\n\t}\n\n\tif (keyStates[256]){\n\t\tspeed = 2.0f;\n\t}\n\telse speed = 0.5f;\n\n\tif (keyStates['f']) {\n\t\tlookAtMatrix[1] -= speed;\n\t\tlookAtMatrix[4] -= speed;\n\t}\n\n\n\tif (keyStates['r']) {\n\t\tlookAtMatrix[1] += speed;\n\t\tlookAtMatrix[4] += speed;\n\t}\n\n\tif (keyStates['a']) {\n\t\tstrafed = -1;\n\t\t\n\t}\n\tif (keyStates['d']) {\n\t\tstrafed = 1;\n\t\t\n\t} \n\tif (keyStates['s']) {\n\t\tmoved = 1;\n\t}\n\tif (keyStates['w']) {\n\t\tmoved = -1;\n\t}\n\n\tif (keyStates['m'] && activeLightsources<8 && toggle) { //+\n\t\tactiveLightsources++;\n\t\ttoggle=0;\n\t}\n\t\n\tif (keyStates['n'] && activeLightsources>0 && toggle) { //-\n\t\tactiveLightsources--;\n\t\ttoggle=0;\n\t}\n\t\n\tif(strafed)\n\t{\n\t\tGLfloat x, z;\n\t\tx = strafed*cos(angleY)*speed;\n\t\tz = strafed*sin(angleY)*speed;\n\t\tlookAtMatrix[0] += x;\n\t\tlookAtMatrix[2] += z;\n\t\tlookAtMatrix[3] += x;\n\t\tlookAtMatrix[5] += z;\n\t}\n\tif(moved)\n\t{\n\t\tGLfloat x, z;\n\t\tx = moved*-sin(angleY)*speed;\n\t\tz = moved*cos(angleY)*speed;\n\t\tlookAtMatrix[0] += x;\n\t\tlookAtMatrix[2] += z;\n\t\tlookAtMatrix[3] += x;\n\t\tlookAtMatrix[5] += z;\n\t}\n\n\n\n\tif (keyStates[27]) {\n\t\texit(0);\n\t}\n\n\tif (keyStates[32] && player->dy <= 0.0001f && player->dy >= -0.0001f) {\n\t\tplayer->dy = 10.0f;\n\t}\n\tif (keyStates['b']) {\n\t\tlookAtMatrix[0] = startposX;lookAtMatrix[1] = 20.0; lookAtMatrix[2] = startposZ;\n\t\tlookAtMatrix[3] = startposX;lookAtMatrix[4] = 20.0; lookAtMatrix[5] = -startposZ;\n\t\tlookAtMatrix[6] = 0.0f;lookAtMatrix[7] = 1.0f;lookAtMatrix[8] = 0.0f;\n\t\tangleY = 0.0f; \t\tangleX = 0.0f;\n\t} \n}\n\n\n\nvoid init(void)\n{\n \tsrand((unsigned)time(NULL));  \n\tarrow = CreateArrow(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n\tfor(int i=0;i<numBunnies;i++) {\n\t\tbunnyArray[i] = CreateBunny();\n\t}\n\tfor(int i=0;i<100;i++) {\n\t\tgrenboxArray[i] = CreateGrenbox();\n\t}\n\tplayer = CreatePlayer();\n\torc = CreateOrc();\n\n\t\nprintf(\"BunnyIsland init\");\n}\n\n\nvoid drawScene(int reflect)\n{\n\n\t\t\n\tdrawWindmill(650.0f,getGroundHeight(650.0f,448.0f),448.0f,reflect);\n\tdrawCastle(CastleX,getGroundHeight(CastleX,CastleZ),CastleZ, reflect);\n\n\tfor(int i=0;i<numBunnies;i++)\n\t\tdrawBunny(bunnyArray[i]->x, bunnyArray[i]->y+1.2f, bunnyArray[i]->z, bunnyArray[i]->ry, reflect);\n\tfor(int i=0;i<activeLightsources;i++)\n\t\tdrawLightpost(lpArray[i]->x, lpArray[i]->z, reflect);\n\tfor(int i=0;i<100;i++)\n\t\tif(grenboxArray[i]->alive>0.5) drawGrenbox(grenboxArray[i]->x,grenboxArray[i]->y,grenboxArray[i]->z,grenboxArray[i]->ry, reflect);\n\t\t\n\tdrawOrc(orc->x,orc->y, orc->z, orc->ry, orc->size, reflect);\n\tdrawArrow(arrow->x, arrow->y, arrow->z, arrow->ry, arrow->rz, reflect);\n\tdrawGround(reflect);\n\n}\n\nvoid display(void)\n{\n//\tprintError(\"pre display\");\n\t// clear the screen\n\tglClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT);\n\tif(0) { // if reflections\n\t  drawScene(0);\n\t  glEnable(GL_STENCIL_TEST);\n\t  glColorMask(0, 0, 0, 0); //Disable drawing colors to the screen\n\t  glStencilFuncSeparate(GL_FRONT,GL_ALWAYS, 1, 1); //Make the stencil test always pass\n\t  //Make pixels in the stencil buffer be set to 1 when the stencil test passes\n\t  glStencilOpSeparate(GL_FRONT,GL_KEEP, GL_KEEP, GL_REPLACE);\n\t  //Set all of the pixels covered by the floor to be 1 in the stencil buffer\n\t  drawWater();\n\t  glColorMask(1, 1, 1, 1); //Enable drawing colors to the screen\n\t  glClear(GL_DEPTH_BUFFER_BIT);\n\t  glDisable(GL_STENCIL_TEST);\n\t  drawSky();\n\t  glEnable(GL_STENCIL_TEST);\n\n\t  //Make the stencil test pass only when the pixel is 1 in the stencil buffer\n\t  glStencilFuncSeparate(GL_FRONT,GL_EQUAL, 1, 1);\n\t  glStencilOpSeparate(GL_FRONT,GL_KEEP, GL_KEEP, GL_KEEP); //Make the stencil buffer not change\n\t  \n\t  // <RITA UT REFLEKTIONER!!!>\n\t  drawScene(1);\n\t  // </RITA UT REFLEKTIONER!!!>\n\t  \n\t  glDisable(GL_STENCIL_TEST);\n\t  drawWater();\n\t  drawScene(0);\n\t}\n\telse {\n\t  drawSky();\n\t  drawScene(0);\n\t  drawWater();\n\t}\n\n\n\t\n\n\tchar tempbuf[5];\n    sprintf(tempbuf, \"%d\", fps);\n\tchar fpsbuf[12] = \"FPS: \";\n\tstrcat(fpsbuf,tempbuf);\n\tchar tempbuf2[5];\n\tsprintf(tempbuf2, \"%d\", level);\n\tchar levelbuf[14] =\"Level: \";\n\tstrcat(levelbuf,tempbuf2);\n\tchar tempbuf3[5];\n\tsprintf(tempbuf3, \"%d\", castlehp);\n\tchar castlebuf[18] =\"Castle hp: \";\n\tstrcat(castlebuf,tempbuf3);\n\tchar tempbuf4[50];\n\tsprintf(tempbuf4, \"%d\", grenades);\n\tchar timebuf[70] =\"Grenades: \";\n\tstrcat(timebuf,tempbuf4);\n\tchar tempbuf5[50];\n\tif(closestGrenboxDist<9000) sprintf(tempbuf5, \"%.2f\", closestGrenboxDist);// OVER NINE THOUSAND\n\telse strcpy(tempbuf5, \"N/A\");\n\tchar distbuf[90] =\"Distance to closest grenade box: \";\n\tstrcat(distbuf,tempbuf5);\n\n\t/*drawText(-0.9f,0.9f,fpsbuf); need workaround\n\tdrawText(-0.2f,0.9f,levelbuf);\n\tdrawText(0.5f,0.9f,castlebuf);\n\tdrawText(-0.6f,-0.9f,timebuf);\n\tdrawText(0.0f,-0.9f,distbuf);\n\n\tif(tid<5000) drawText(-0.2f,0.0f,\"PROTECT THE CASTLE!\");\n\t*/\n\tif(level>99)\n\t{\n\t\tgameOver=1;\n\t\t//drawText(0.0f,0.0f,\"YOU WIN!\");\n\t}\n\tif(castlehp<=0)\n\t{\n\t\tgameOver=1;\n\t\t//drawText(0.0f,0.0f,\"GAME OVER!\");\t\n\t}\n\n\n\tglutSwapBuffers();\n}\nvoid OnTimer(int value)\n{\n\tticktid = glutGet(GLUT_ELAPSED_TIME) - tid;\n\ttid = glutGet(GLUT_ELAPSED_TIME);\n\tkeyOperations();\n\t//printf(\"height: %f\\n\", player->y);\n\t//printf(\"angleX: %f\\n\", angleX);\n\tTickPlayer(player);\n\tlookAt(lookAtMatrix[0],lookAtMatrix[1],lookAtMatrix[2],\n\t\t\tlookAtMatrix[3],lookAtMatrix[4],lookAtMatrix[5],\n\t\t\tlookAtMatrix[6],lookAtMatrix[7],lookAtMatrix[8],&cameraMatrix[0]);\n\ttemp_x = cameraMatrix[3];\n\ttemp_y = cameraMatrix[7];\n\ttemp_z = cameraMatrix[11];\n\tcameraMatrix[3] = 0.0;\n\tcameraMatrix[7] = 0.0;\n\tcameraMatrix[11] = 0.0;\n\tcameraMatrix[3] = temp_x;\n\tcameraMatrix[7] = temp_y;\n\tcameraMatrix[11] = temp_z;\n\tnumFrames++;\n\n/// GAME LOGIC\n\tint count = 0;\n\n\tfor(int i=0;i<numBunnies;i++) {\n\t\tTickBunny(bunnyArray[i]);\n\t\tif(bunnyArray[i]->hp < 1.0f) {\n\t\t\tcount++;\n\t\t}\n\t}\n\tif(count>=NEXTLVLLIMIT) {\n\t\torc->size++;\n\t\torc->ds+=0.01;\n\t\tlevel++;\n\t\tprintf(\"NOW ON LEVEL: %i\\n\", level);\n\t\tif(level%2==0) grenboxArray[level/2]->alive = 1.0f;\n\t\tfor(int i=0;i<numBunnies;i++) {\n\t\t\tif(bunnyArray[i]->hp < 1.0f) {\n\t\t\t\tbunnyArray[i]->hp = 1;\n\t\t\t\tbunnyArray[i]->x = orc->x; \n\t\t\t\tbunnyArray[i]->y = orc->y;\n\t\t\t\tbunnyArray[i]->z = orc->z;\n\t\t\t\tbunnyArray[i]->ds+=0.01;\n\t\t\t}\n\t\t}\n\t}\n\n\tclosestGrenboxDist = 10000.0f;\n\tfor(int i=0;i<100;i++) {\n\t\tTickGrenbox(grenboxArray[i]);\n\t\tif(grenboxArray[i]->alive>0.5)\n\t\t\t{\n\t\t\t\ttempdist = sqrt((player->x-grenboxArray[i]->x)*(player->x-grenboxArray[i]->x)+(player->z-grenboxArray[i]->z)*(player->z-grenboxArray[i]->z));\n\t\t\t\tif(tempdist<closestGrenboxDist) closestGrenboxDist = tempdist;\n\t\t\t}\n\t}\n\tTickArrow(arrow);\n\tTickOrc(orc);\n\n/// END GAME LOGIC\n\n\tif((tid-timeSinceLastFpsCheck) > 1000)\n\t{\n\t\tfps = numFrames;\n\t\ttimeSinceLastFpsCheck = tid;\n\t\tnumFrames = 0;\n\t}\n\n\t    if(gameOver==0)glutPostRedisplay();\n    \tglutTimerFunc(17, &OnTimer, value);\n\n}\n\n\n\nint main(int argc, char *argv[])\n{\n\n\tglutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH | GLUT_STENCIL);\n\tglutCreateWindow (\"Bunny Island: Heroes Never Die\");\n\tGLenum err = glewInit();\n\tif (GLEW_OK != err)\n\t{\n  \t\t/* Problem: glewInit failed, something is seriously wrong. */\n  \t\tfprintf(stderr, \"Error: %s\\n\", glewGetErrorString(err));\n\t}\n\n\tfprintf(stdout, \"Status: Using GLEW %s\\n\", glewGetString(GLEW_VERSION));\n\tglutKeyboardFunc(keyPressed); // Tell GLUT to use the method \"keyPressed\" for key presses  \n\tglutKeyboardUpFunc(keyUpp); // Tell GLUT to use the method \"keyUp\"\n\tglutPassiveMotionFunc(mouseMove);\n\tglutMotionFunc(mouseMove);\n\tglutMouseFunc(mouseClick);\n\tglutDisplayFunc(display);\n\n\t//glutSetCursor(GLUT_CURSOR_NONE);\n\tprintf(\"INIT done!\\n\");\n\n\tinitDraw();\t\n\tinit();\n\n\tglutReshapeWindow(WIDTH, HEIGHT);\n\tglutTimerFunc(17, &OnTimer, 0);\n\tglutMainLoop();\n\n}\n","// GL utilities, bare essentials\n\n//#define GL3_PROTOTYPES\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <string.h>\n\n#include \"GL_utilities.h\"\n\n// From ShaderLoader\n\nchar* readFile(char *file)\n{\n\tFILE *fptr;\n\tlong length;\n\tchar *buf;\n\t\n\tfptr = fopen(file, \"r\"); /* Open file for reading */\n\tif (!fptr) /* Return NULL on failure */\n\t\treturn NULL;\n\tfseek(fptr, 0, SEEK_END); /* Seek to the end of the file */\n\tlength = ftell(fptr); /* Find out how many bytes into the file we are */\n\tbuf = (char*)malloc(length+1); /* Allocate a buffer for the entire length of the file and a null terminator */\n\tfseek(fptr, 0, SEEK_SET); /* Go back to the beginning of the file */\n\tfread(buf, length, 1, fptr); /* Read the contents of the file in to the buffer */\n\tfclose(fptr); /* Close the file */\n\tbuf[length] = 0; /* Null terminator */\n\t\n\treturn buf; /* Return the buffer */\n}\n\n// Infolog: Show result of shader compilation\nvoid printShaderInfoLog(GLuint obj)\n{\n\tGLint infologLength = 0;\n\tGLint charsWritten  = 0;\n\tchar *infoLog;\n\n\tglGetShaderiv(obj, GL_INFO_LOG_LENGTH, &infologLength);\n\n\tif (infologLength > 0)\n\t{\n\t\tinfoLog = (char *)malloc(infologLength);\n\t\tglGetShaderInfoLog(obj, infologLength, &charsWritten, infoLog);\n\t\tprintf(\"%s\\n\",infoLog);\n\t\tfree(infoLog);\n\t}\n}\n\nvoid printProgramInfoLog(GLuint obj)\n{\n\tGLint infologLength = 0;\n\tGLint charsWritten  = 0;\n\tchar *infoLog;\n\n\tglGetProgramiv(obj, GL_INFO_LOG_LENGTH,&infologLength);\n\n\tif (infologLength > 0)\n\t{\n\t\tinfoLog = (char *)malloc(infologLength);\n\t\tglGetProgramInfoLog(obj, infologLength, &charsWritten, infoLog);\n\t\tprintf(\"%s\\n\",infoLog);\n\t\tfree(infoLog);\n\t}\n}\n\n// Compile a shader, return reference to it\nGLuint compileShaders(const char *vs, const char *fs)\n{\n\tGLuint v,f,p;\n\n\tv = glCreateShader(GL_VERTEX_SHADER);\n\tf = glCreateShader(GL_FRAGMENT_SHADER);\n\tglShaderSource(v, 1, &vs, NULL);\n\tglShaderSource(f, 1, &fs, NULL);\n\tglCompileShader(v);\n\tglCompileShader(f);\n\tp = glCreateProgram();\n\tglAttachShader(p,v);\n\tglAttachShader(p,f);\n\tglLinkProgram(p);\n\tglUseProgram(p);\n\t\n\tprintShaderInfoLog(v);\n\tprintShaderInfoLog(f);\n\tprintProgramInfoLog(p);\n\t\n\treturn p;\n}\n\nGLuint loadShaders(const char *vertFileName, const char *fragFileName)\n// TO DO: Add geometry shader support\n{\n\t// const \n\tchar *vs, *fs;\n\tGLuint p;\n\t\n\tvs = readFile((char *)vertFileName);\n\tfs = readFile((char *)fragFileName);\n\tif ((vs==NULL)||(fs==NULL))\n\t{\n\t\tprintf(\"Loading shaders failed.\\n\");\n\t\treturn 0;\n\t}\n\t\n\tp = compileShaders(vs, fs);\n\tif (vs != NULL) free(vs);\n\tif (fs != NULL) free(fs);\n\treturn p;\n}\n\n// End of ShaderLoader\n\n\nvoid dumpInfo(void)\n{\n   printf (\"Vendor: %s\\n\", glGetString (GL_VENDOR));\n   printf (\"Renderer: %s\\n\", glGetString (GL_RENDERER));\n   printf (\"Version: %s\\n\", glGetString (GL_VERSION));\n   printf (\"GLSL: %s\\n\", glGetString (GL_SHADING_LANGUAGE_VERSION));\n   printError (\"dumpInfo\");\n}\n\n/* report GL errors, if any, to stderr */\nvoid printError(const char *functionName)\n{\n   GLenum error;\n   while (( error = glGetError() ) != GL_NO_ERROR)\n   {\n\t  fprintf (stderr, \"GL error 0x%X detected in %s\\n\", error, functionName);\n   }\n}\n\n\n\n\n\n// Keymap mini manager\n// Important! Uses glutKeyboardFunc/glutKeyboardUpFunc so you can't use them\n// elsewhere or they will conflict.\n\nchar keymap[256];\n\nchar keyIsDown(unsigned char c)\n{\n\treturn keymap[(unsigned int)c];\n}\n\nvoid keyUp(unsigned char key, int x, int y)\n{\n\tkeymap[(unsigned int)key] = 0;\n}\n\nvoid keyDown(unsigned char key, int x, int y)\n{\n\tkeymap[(unsigned int)key] = 1;\n}\n\nvoid initKeymapManager()\n{\n\tint i;\n\tfor (i = 0; i < 256; i++) keymap[i] = 0;\n\t\n\tglutKeyboardFunc(keyDown);\n\tglutKeyboardUpFunc(keyUp);\n}\n","// LoadOBJ\n// by Ingemar Ragnemalm 2005, 2008\n// Developed with CodeWarrior and Lightweight IDE on Mac OS/Mac OSX\n\n// Assumes that gcc is set to -std=c99\n\n// Extended version with LoadModelPlus\n\n#include \"loadobj.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define PI 3.141592\n\n\ntypedef struct Mesh\n{\n  GLfloat\t*vertices;\n  int\t\tvertexCount;\n  GLfloat\t*vertexNormals;\n  int\t\tnormalsCount; // Same as vertexCount for generated normals\n  GLfloat\t*textureCoords;\n  int\t\ttexCount;\n\n  int\t\t*coordIndex;\n  int\t\t*normalsIndex;\n  int\t\t*textureIndex;\n  int\t\tcoordCount; // Number of indices in each index struct\n\t\n  int\t\t*triangleCountList;\n  int\t\t**vertexToTriangleTable;\n\t\n  GLfloat radius; // Enclosing sphere\n  GLfloat radiusXZ; // For cylindrical tests\n} Mesh, *MeshPtr;\n\n\n\n#define vToken        1\n#define vnToken       2\n#define vtToken       3\n#define kReal         4\n#define kInt          5\n#define tripletToken  6\n#define fToken        7\n#define crlfToken     8\n#define kEOF          9\n#define kUnknown     10\n\n\nstatic FILE *fp;\n\nstatic int intValue[3];\nstatic float floatValue[3];\nstatic int vertCount, texCount, normalsCount, coordCount;\n\n#ifndef false\n#define false 0\n#endif\n#ifndef true\n#define true 1\n#endif\n#ifndef bool\n#define bool char\n#endif\n\nstatic bool hasPositionIndices;\nstatic bool hasNormalIndices;\nstatic bool hasTexCoordIndices;\n\nstatic bool atLineEnd; // Helps SkipToCRLF\n\n\nstatic void OBJGetToken(int * tokenType)\n{\n  char c;\n  char s[255];\n  int i;\n\t\n  // 1. skip space. Check for #, skip line when found\n  c = getc(fp);\n  while (c == 32 || c == 9 || c == '#')\n    {\n      while (c == '#')\n\twhile (c != 13 && c != 10 && c != EOF)\n\t  c = getc(fp); // Skip comment\n      c = getc(fp);\n    }\n\t\n  // Inspect first character. Bracket, number, other?\n\t\n  if (c == 13 || c == 10)\n    {\n      *tokenType = crlfToken;\n      //\t\twhile (c == 13 && c == 10)\n      //\t\t\t\tc = getc(fp);\n    }\n  else\n    if ((c >= '0' && c <= '9') || c == '-' || c == '.') // Numerical value\n      {\n\t*tokenType = kInt;\n\ti = 0;\n\twhile (c != 13 && c != 10 && c != 32 && c != 9 && c != '/' && c != EOF)\n\t  {\n\t    if (c == '.' || c == 'E')\n\t      *tokenType = kReal;\n\t    s[i++] = c;\n\t    c = getc(fp);\n\t  }\n\ts[i] = 0;\n\tsscanf(s, \"%f\", &floatValue[0]);\n\tsscanf(s, \"%d\", &intValue[0]);\n\t// Check for /\n\tif (c == '/') // parse another number\n\t  {\n\t    c = getc(fp);\n\t    i = 0;\n\t    while (c != 13 && c != 10 && c != 32 && c != 9 && c != '/' && c != EOF)\n\t      {\n\t\ts[i++] = c;\n\t\tc = getc(fp);\n\t      }\n\t    s[i] = 0;\n\t\t\t\n\t    if (i == 0)\n\t      {\n\t\tfloatValue[1] = -1;\n\t\tintValue[1] = -1;\n\t      }\n\t    else\n\t      {\n\t\tsscanf(s, \"%f\", &floatValue[1]);\n\t\tsscanf(s, \"%d\", &intValue[1]);\n\t      }\n\t    *tokenType = tripletToken;\n\t  }\n\tif (c == '/') // parse one more number\n\t  {\n\t    c = getc(fp);\n\t    i = 0;\n\t    while (c != 13 && c != 10 && c != 32 && c != 9 && c != '/' && c != EOF)\n\t      {\n\t\ts[i++] = c;\n\t\tc = getc(fp);\n\t      }\n\t    s[i] = 0;\n\n\t    if (i == 0)\n\t      {\n\t\tfloatValue[2] = -1;\n\t\tintValue[2] = -1;\n\t      }\n\t    else\n\t      {\n\t\tsscanf(s, \"%f\", &floatValue[2]);\n\t\tsscanf(s, \"%i\", &intValue[2]);\n\t      }\n\t    *tokenType = tripletToken;\n\t  }\n      }\n    else\n      if (c == EOF)\n\t{\n\t  *tokenType = kEOF;\n\t}\n      else // Other\n\t{\n\t  i = 0;\n\t  while (c != 13 && c != 10 && c != 32 && c != 9 && c != EOF)\n\t    {\n\t      s[i++] = c;\n\t      c = getc(fp);\n\t    }\n\t  s[i] = 0;\n\t\t\n\t  *tokenType = kUnknown;\n\t  // Compare string to symbols\n\t\t\n\t  if (strcmp(s, \"v\") == 0)\n\t    *tokenType = vToken;\n\t  if (strcmp(s, \"vn\") == 0)\n\t    *tokenType = vnToken;\n\t  if (strcmp(s, \"vt\") == 0)\n\t    *tokenType = vtToken;\n\t  if (strcmp(s, \"f\") == 0)\n\t    *tokenType = fToken;\n\t}\n  atLineEnd = (c == 13 || c == 10);\n} // ObjGetToken\n\nstatic void SkipToCRLF()\n{\n  char c = 0;\n\t\n  if (!atLineEnd)\n    while (c != 10 && c != 13 && c != EOF)\n      c = getc(fp);\n  //\twhile (tokenType != crlfToken && tokenType != kEOF)\n  //\t\tOBJGetToken(&tokenType);\n}\n\n//static void SkipToCRLF(int tokenType)\n//{\n//\twhile (tokenType != crlfToken && tokenType != kEOF)\n//\t\tOBJGetToken(&tokenType);\n//}\n\nstatic void ReadOneVertex(MeshPtr theMesh)\n{\n  GLfloat x=0.0f, y=0.0f, z=0.0f;\n  int tokenType;\n\n  // Three floats expected\n  OBJGetToken(&tokenType);\n  if (tokenType == kInt || tokenType == kReal)\n    x = floatValue[0];\n  OBJGetToken(&tokenType);\n  if (tokenType == kInt || tokenType == kReal)\n    y = floatValue[0];\n  OBJGetToken(&tokenType);\n  if (tokenType == kInt || tokenType == kReal)\n    z = floatValue[0];\n  SkipToCRLF();\n\t\n  // Write to array if it exists\n  if (theMesh->vertices != NULL)\n    {\n      theMesh->vertices[vertCount++] = x;\n      theMesh->vertices[vertCount++] = y;\n      theMesh->vertices[vertCount++] = z;\n    }\n  else\n    vertCount = vertCount + 3;\n}\n\nstatic void ReadOneTexture(MeshPtr theMesh)\n{\n  int tokenType;\n  GLfloat s=0.0f, t=0.0f;\n\n  // Two floats expected\n  OBJGetToken(&tokenType);\n  if (tokenType == kInt || tokenType == kReal)\n    s = floatValue[0];\n  OBJGetToken(&tokenType);\n  if (tokenType == kInt || tokenType == kReal)\n    t = floatValue[0];\n  SkipToCRLF();\n\t\n  // Write to array if it exists\n  if (theMesh->textureCoords != NULL)\n    {\n      theMesh->textureCoords[texCount++] = s;\n      theMesh->textureCoords[texCount++] = t;\n    }\n  else\n    texCount = texCount + 2;\n}\n\nstatic void ReadOneNormal(MeshPtr theMesh)\n{\n  int tokenType;\n  GLfloat x=0.0f, y=0.0f, z=0.0f;\n\n  // Three floats expected\n  OBJGetToken(&tokenType);\n  if (tokenType == kInt || tokenType == kReal)\n    x = floatValue[0];\n  OBJGetToken(&tokenType);\n  if (tokenType == kInt || tokenType == kReal)\n    y = floatValue[0];\n  OBJGetToken(&tokenType);\n  if (tokenType == kInt || tokenType == kReal)\n    z = floatValue[0];\n  SkipToCRLF();\n\t\n  // Write to array if it exists\n  if (theMesh->vertexNormals != NULL)\n    {\n      theMesh->vertexNormals[normalsCount++] = x;\n      theMesh->vertexNormals[normalsCount++] = y;\n      theMesh->vertexNormals[normalsCount++] = z;\n    }\n  else\n    normalsCount = normalsCount + 3;\n}\n\nstatic void ReadOneFace(MeshPtr theMesh)\n{\n  int tokenType;\n  bool triplets = false;\n\n  // OBS! Unknown number! Can be one single vertex index or a triplet\n  do\n    {\n      OBJGetToken(&tokenType);\n\t\t\n      switch (tokenType)\n\t{\n\tcase kReal: // Real should not happen\n\tcase kInt:\n\t  if (intValue[0] != 0)\n\t    {\n\t      hasPositionIndices = true;\n\n\t      // Single index\n\t      if (theMesh->coordIndex != NULL)\n\t\t{\n\t\t  if (intValue[0] >= 0)\n\t\t    theMesh->coordIndex[coordCount] = intValue[0]-1;\n\t\t  else\n\t\t    theMesh->coordIndex[coordCount] =\n\t\t      vertCount / 3 + intValue[0];\n\t\t}\n\t    }\n\t  break;\n\tcase tripletToken:\n\t  // Triplet (out of which some may be missing)\n\n\t  if (intValue[0] != 0)\n\t    {\n\t      hasPositionIndices = true;\n\n\t      if (theMesh->coordIndex != NULL)\n\t\t{\n\t\t  if (intValue[0] > 0)\n\t\t    theMesh->coordIndex[coordCount] = intValue[0]-1;\n\t\t  else\n\t\t    theMesh->coordIndex[coordCount] =\n\t\t      vertCount+intValue[0];\n\t\t}\n\t    }\n\t  if (intValue[1] != 0)\n\t    {\n\t      hasTexCoordIndices = true;\n\n\t      if (theMesh->textureIndex != NULL)\n\t\t{\n\t\t  if (intValue[1] > 0)\n\t\t    theMesh->textureIndex[coordCount] = intValue[1]-1;\n\t\t  else\n\t\t    theMesh->textureIndex[coordCount] =\n\t\t      texCount / 2 + intValue[1];\n\t\t}\n\t    }\n\t  if (intValue[2] != 0)\n\t    {\n\t      hasNormalIndices = true;\n\n\t      if (theMesh->normalsIndex != NULL)\n\t\t{\n\t\t  if (intValue[2] >= 0)\n\t\t    theMesh->normalsIndex[coordCount] = intValue[2]-1;\n\t\t  else\n\t\t    theMesh->normalsIndex[coordCount] = \n\t\t      normalsCount / 3 + intValue[2];\n\t\t}\n\t    }\n\t  triplets = true;\n\t  break;\n\t}\n\n      coordCount++;\n    }\n  while (tokenType != kEOF && (tokenType != crlfToken) != atLineEnd);\n\n  // Terminate polygon with -1 (like VRML)\n  if (theMesh->coordIndex != NULL)\n    {\n      theMesh->coordIndex[coordCount] = -1;\n    }\n  if (triplets)\n    {\n      if (theMesh->textureIndex != NULL)\n\t{\n\t  theMesh->textureIndex[coordCount] = -1;\n\t}\n      if (theMesh->normalsIndex != NULL)\n\t{\n\t  theMesh->normalsIndex[coordCount] = -1;\n\t}\n    }\n\n  coordCount++;\n}\n\nstatic void ParseOBJ(MeshPtr theMesh)\n{\n  int tokenType;\n\t\n  tokenType = 0;\n  while (tokenType != kEOF)\n    {\n      OBJGetToken(&tokenType);\n      switch (tokenType)\n\t{\n\tcase vToken:\n\t  ReadOneVertex(theMesh);\n\t  break;\n\tcase vnToken:\n\t  ReadOneNormal(theMesh);\n\t  break;\n\tcase vtToken:\n\t  ReadOneTexture(theMesh);\n\t  break;\n\tcase fToken:\n\t  ReadOneFace(theMesh);\n\t  break;\n\tcase kReal:\n\t  // Ignore\n\t  break;\n\tcase crlfToken:\n\t  break;\n\tcase kUnknown:\n\t  SkipToCRLF();\n\t  //while (tokenType != crlfToken && tokenType != kEOF)\n\t  //\tOBJGetToken(&tokenType);\n\t  break;\n\t}\n    }\n}\n\n\nstatic struct Mesh * LoadOBJ(const char *filename)\n{\n  Mesh *theMesh;\n\t\n  theMesh = malloc(sizeof(Mesh));\n  theMesh->coordIndex = NULL;\n  theMesh->vertices = NULL;\n  // ProcessMesh may deal with these\n  theMesh->triangleCountList = NULL;\n  theMesh->vertexNormals = NULL;\n  theMesh->vertexToTriangleTable = NULL;\n  theMesh->textureCoords = NULL;\n  theMesh->textureIndex = NULL;\n  theMesh->normalsIndex = NULL;\n\n  hasPositionIndices = true;\n  hasTexCoordIndices = false;\n  hasNormalIndices = false;\n\t\n  vertCount=0;\n  texCount=0;\n  normalsCount=0;\n  coordCount=0;\n\t\n  fp = fopen(filename, \"r\");\n  if (fp == NULL)\n    {\n      fprintf(stderr, \"Unable to open file\\n\");\n      fflush(stderr);\n      return NULL;\n    }\n  ParseOBJ(theMesh);\n  fclose(fp);\n\n  // Allocate arrays!\n  if (vertCount > 0)\n    theMesh->vertices = malloc(sizeof(GLfloat) * vertCount);\n  if (texCount > 0)\n    theMesh->textureCoords = malloc(sizeof(GLfloat) * texCount);\n  if (normalsCount > 0)\n    theMesh->vertexNormals = malloc(sizeof(GLfloat) * normalsCount);\n  if (hasPositionIndices)\n    theMesh->coordIndex = malloc(sizeof(int) * coordCount);\n  if (hasNormalIndices)\n    theMesh->normalsIndex = malloc(sizeof(int) * coordCount);\n  if (hasTexCoordIndices)\n    theMesh->textureIndex = malloc(sizeof(int) * coordCount);\n\t\n  // Zero again\n  vertCount=0;\n  texCount=0;\n  normalsCount=0;\n  coordCount=0;\n\n  fp = fopen(filename, \"r\");\n  if (fp == NULL) return NULL;\n  ParseOBJ(theMesh);\n  fclose(fp);\n\t\n  theMesh->vertexCount = vertCount/3;\n  theMesh->coordCount = coordCount;\n\t\n  // Counters for tex and normals, texCount and normalsCount\n  theMesh->texCount = texCount/2;\n  theMesh->normalsCount = normalsCount/3; // Should be the same as vertexCount!\n  // This assumption could make handling of some models break!\n\t\n  return theMesh;\n}\n\nvoid DecomposeToTriangles(struct Mesh *theMesh)\n{\n  int i, vertexCount, triangleCount;\n  int *newCoords, *newNormalsIndex=0, *newTextureIndex=0;\n\t\n  // 1. Bygg om hela modellen till trianglar\n  // 1.1 Calculate how big the list will become\n\t\n  vertexCount = 0; // Number of vertices in current polygon\n  triangleCount = 0; // Resulting number of triangles\n  for (i = 0; i < theMesh->coordCount; i++)\n    {\n      if (theMesh->coordIndex[i] == -1)\n\t{\n\t  if (vertexCount > 2) triangleCount += vertexCount - 2;\n\t  vertexCount = 0;\n\t}\n      else\n\t{\n\t  vertexCount = vertexCount + 1;\n\t}\n    }\n\t\n  printf(\"Found %d triangles\\n\", triangleCount);\n\t\n  newCoords = malloc(sizeof(int) * triangleCount * 3);\n  if (theMesh->normalsIndex != NULL)\n    newNormalsIndex = malloc(sizeof(int) * triangleCount * 3);\n  if (theMesh->textureIndex != NULL)\n    newTextureIndex = malloc(sizeof(int) * triangleCount * 3);\n\t\n  // 1.2 Loop through old list and write the new one\n  // Almost same loop but now it has space to write the result\n  vertexCount = 0;\n  int newIndex = 0; // Index in newCoords\n  int first = 0;\n  for (i = 0; i < theMesh->coordCount; i++)\n    {\n      if (theMesh->coordIndex[i] == -1)\n\t{\n\t  first = i + 1;\n\t  vertexCount = 0;\n\t}\n      else\n\t{\n\t  vertexCount = vertexCount + 1;\n\n\t  if (vertexCount > 2)\n\t    {\n\t      newCoords[newIndex++] = theMesh->coordIndex[first];\n\t      newCoords[newIndex++] = theMesh->coordIndex[i-1];\n\t      newCoords[newIndex++] = theMesh->coordIndex[i];\n\t\t\t\t\n\t      if (theMesh->normalsIndex != NULL)\n\t\t{\n\t\t  newNormalsIndex[newIndex-3] = theMesh->normalsIndex[first];\n\t\t  newNormalsIndex[newIndex-2] = theMesh->normalsIndex[i-1];\n\t\t  newNormalsIndex[newIndex-1] = theMesh->normalsIndex[i];\n\t\t}\n\t\t\t\t\n\t      // Dito for textures\n\t      if (theMesh->textureIndex != NULL)\n\t\t{\n\t\t  newTextureIndex[newIndex-3] = theMesh->textureIndex[first];\n\t\t  newTextureIndex[newIndex-2] = theMesh->textureIndex[i-1];\n\t\t  newTextureIndex[newIndex-1] = theMesh->textureIndex[i];\n\t\t}\n\t\t\t\t\n\t    }\n\t}\n    }\n\t\n  free(theMesh->coordIndex);\n  theMesh->coordIndex = newCoords;\n  theMesh->coordCount = triangleCount * 3;\n  if (theMesh->normalsIndex != NULL)\n    {\n      free(theMesh->normalsIndex);\n      theMesh->normalsIndex = newNormalsIndex;\n\t\t\n    }\n  if (theMesh->textureIndex != NULL)\n    {\n      free(theMesh->textureIndex);\n      theMesh->textureIndex = newTextureIndex;\n\t\t\n    }\n} // DecomposeToTriangles\n\n\nstatic void generateNormals(Mesh* mesh)\n{\n  // If model has vertices but no vertexnormals, generate normals\n  if (mesh->vertices && !mesh->vertexNormals)\n    {\n      int face;\n      int normalIndex;\n\n      mesh->vertexNormals = malloc(3 * sizeof(GLfloat) * mesh->vertexCount);\n      memset(mesh->vertexNormals, 0, 3 * sizeof(GLfloat) * mesh->vertexCount);\n\n      mesh->normalsCount = mesh->vertexCount;\n\n      mesh->normalsIndex = malloc(sizeof(GLuint) * mesh->coordCount);\n      memcpy(mesh->normalsIndex, mesh->coordIndex,\n\t     sizeof(GLuint) * mesh->coordCount);\n\n      for (face = 0; face * 3 < mesh->coordCount; face++)\n\t{\n\t  int i0 = mesh->coordIndex[face * 3 + 0];\n\t  int i1 = mesh->coordIndex[face * 3 + 1];\n\t  int i2 = mesh->coordIndex[face * 3 + 2];\n\t  \n\t  GLfloat* vertex0 = &mesh->vertices[i0 * 3];\n\t  GLfloat* vertex1 = &mesh->vertices[i1 * 3];\n\t  GLfloat* vertex2 = &mesh->vertices[i2 * 3];\n\n\t  float v0x = vertex1[0] - vertex0[0];\n\t  float v0y = vertex1[1] - vertex0[1];\n\t  float v0z = vertex1[2] - vertex0[2];\n\n\t  float v1x = vertex2[0] - vertex0[0];\n\t  float v1y = vertex2[1] - vertex0[1];\n\t  float v1z = vertex2[2] - vertex0[2];\n\n\t  float v2x = vertex2[0] - vertex1[0];\n\t  float v2y = vertex2[1] - vertex1[1];\n\t  float v2z = vertex2[2] - vertex1[2];\n\n\t  float sqrLen0 = v0x * v0x + v0y * v0y + v0z * v0z;\n\t  float sqrLen1 = v1x * v1x + v1y * v1y + v1z * v1z;\n\t  float sqrLen2 = v2x * v2x + v2y * v2y + v2z * v2z;\n\n\t  float len0 = (sqrLen0 >= 1e-6) ? sqrt(sqrLen0) : 1e-3;\n\t  float len1 = (sqrLen1 >= 1e-6) ? sqrt(sqrLen1) : 1e-3;\n\t  float len2 = (sqrLen2 >= 1e-6) ? sqrt(sqrLen2) : 1e-3;\n\n\t  float influence0 = (v0x * v1x + v0y * v1y + v0z * v1z) / (len0 * len1);\n\t  float influence1 = -(v0x * v2x + v0y * v2y + v0z * v2z) / (len0 * len2);\n\t  float influence2 = (v1x * v2x + v1y * v2y + v1z * v2z) / (len1 * len2);\n\n\t  float angle0 = (influence0 >= 1.f) ? 0 : \n\t    (influence0 <= -1.f) ? PI : acos(influence0);\n\t  float angle1 = (influence1 >= 1.f) ? 0 : \n\t    (influence1 <= -1.f) ? PI : acos(influence1);\n\t  float angle2 = (influence2 >= 1.f) ? 0 : \n\t    (influence2 <= -1.f) ? PI : acos(influence2);\n\n\t  float normalX = v1z * v0y - v1y * v0z;\n\t  float normalY = v1x * v0z - v1z * v0x;\n\t  float normalZ = v1y * v0x - v1x * v0y;\n\n\t  GLfloat* normal0 = &mesh->vertexNormals[i0 * 3];\n\t  GLfloat* normal1 = &mesh->vertexNormals[i1 * 3];\n\t  GLfloat* normal2 = &mesh->vertexNormals[i2 * 3];\n\n\t  normal0[0] += normalX * angle0;\n\t  normal0[1] += normalY * angle0;\n\t  normal0[2] += normalZ * angle0;\n\n\t  normal1[0] += normalX * angle1;\n\t  normal1[1] += normalY * angle1;\n\t  normal1[2] += normalZ * angle1;\n\n\t  normal2[0] += normalX * angle2;\n\t  normal2[1] += normalY * angle2;\n\t  normal2[2] += normalZ * angle2;\n\t}\n\n      for (normalIndex = 0; normalIndex < mesh->normalsCount; normalIndex++)\n\t{\n\t  GLfloat* normal = &mesh->vertexNormals[normalIndex * 3];\n\t  float length = sqrt(normal[0] * normal[0] + normal[1] * normal[1]\n\t\t\t      + normal[2] * normal[2]);\n\t  float reciprocalLength = 1.f;\n\n\t  if (length > 0.01f)\n\t    reciprocalLength = 1.f / length;\n\n\t  normal[0] *= reciprocalLength;\n\t  normal[1] *= reciprocalLength;\n\t  normal[2] *= reciprocalLength;\n\t}\n    }\n}\n\n\nstatic Model* generateModel(Mesh* mesh)\n{\n  // Convert from Mesh format (multiple index lists) to Model format\n  // (one index list) by generating a new set of vertices/indices\n  // and where new vertices have been created whenever necessary\n\n\n  typedef struct\n  {\n    int positionIndex;\n    int normalIndex;\n    int texCoordIndex;\n    int newIndex;\n  } IndexTriplet;\n\n  int hashGap = 6;\n\n  int indexHashMapSize = (mesh->vertexCount * hashGap + mesh->coordCount);\n\n  IndexTriplet* indexHashMap = malloc(sizeof(IndexTriplet)\n\t\t\t\t      * indexHashMapSize);\n\n  int numNewVertices = 0;\n  int index;\n\n  int maxValue = 0;\n    \n  Model* model = malloc(sizeof(Model));\n  memset(model, 0, sizeof(Model));\n\n  model->indexArray = malloc(sizeof(GLuint) * mesh->coordCount);\n  model->numIndices = mesh->coordCount;\n\n  memset(indexHashMap, 0xff, sizeof(IndexTriplet) * indexHashMapSize);\n\n  for (index = 0; index < mesh->coordCount; index++)\n    {\n      IndexTriplet currentVertex = { -1, -1, -1, -1 };\n      int insertPos = 0;\n      if (mesh->coordIndex)\n\tcurrentVertex.positionIndex = mesh->coordIndex[index];\n      if (mesh->normalsIndex)\n\tcurrentVertex.normalIndex = mesh->normalsIndex[index];\n      if (mesh->textureIndex)\n\tcurrentVertex.texCoordIndex = mesh->textureIndex[index];\n\n      if (maxValue < currentVertex.texCoordIndex)\n\tmaxValue = currentVertex.texCoordIndex;\n \n      if (currentVertex.positionIndex >= 0)\n\tinsertPos = currentVertex.positionIndex * hashGap;\n\n      while (1)\n\t{\n\t  if(insertPos >= indexHashMapSize) break;\n\t  if (indexHashMap[insertPos].newIndex == -1)\n\t    {\n\t      currentVertex.newIndex = numNewVertices++;\n\t      indexHashMap[insertPos] = currentVertex;\n\t      break;\n\t    }\n\t  else if (indexHashMap[insertPos].positionIndex\n\t\t   == currentVertex.positionIndex\n\t\t   && indexHashMap[insertPos].normalIndex\n\t\t   == currentVertex.normalIndex\n\t\t   && indexHashMap[insertPos].texCoordIndex\n\t\t   == currentVertex.texCoordIndex)\n\t    {\n\t      currentVertex.newIndex = indexHashMap[insertPos].newIndex;\n\t      break;\n\t    }\n\t  else\n\t    insertPos++;\n\t} \n\n\n      model->indexArray[index] = currentVertex.newIndex;\n    }\n\n  if (mesh->vertices)\n    model->vertexArray = malloc(sizeof(GLfloat) * 3 * numNewVertices);\n  if (mesh->vertexNormals)\n    model->normalArray = malloc(sizeof(GLfloat) * 3 * numNewVertices);\n  if (mesh->textureCoords)\n    model->texCoordArray = malloc(sizeof(GLfloat) * 2 * numNewVertices);\n  \n  model->numVertices = numNewVertices;\n\n  for (index = 0; index < indexHashMapSize; index++)\n    {\n      if (indexHashMap[index].newIndex != -1)\n\t{\n\t  if (mesh->vertices)\n\t    memcpy(&model->vertexArray[3 * indexHashMap[index].newIndex],\n\t\t   &mesh->vertices[3 * indexHashMap[index].positionIndex],\n\t\t   3 * sizeof(GLfloat));\n\n\t  if (mesh->vertexNormals)\n\t    memcpy(&model->normalArray[3 * indexHashMap[index].newIndex],\n\t\t   &mesh->vertexNormals[3 * indexHashMap[index].normalIndex],\n\t\t   3 * sizeof(GLfloat));\n\n\t  if (mesh->textureCoords)\n\t    {\n\t      model->texCoordArray[2 * indexHashMap[index].newIndex + 0]\n\t\t= mesh->textureCoords[2 * indexHashMap[index].texCoordIndex + 0];\n\t      model->texCoordArray[2 * indexHashMap[index].newIndex + 1]\n\t\t= 1 - mesh->textureCoords[2 * indexHashMap[index].texCoordIndex + 1];\n\t    }\n\t}\n    }\n\n  free(indexHashMap);\n\n  return model;\n}\n\n\nModel* LoadModel(char* name)\n{\n  Model* model = 0;\n  Mesh* mesh = LoadOBJ(name);\n\n  if (!mesh)\n    return 0;\n\n  DecomposeToTriangles(mesh);\n\n  generateNormals(mesh);\n\n  model = generateModel(mesh);\n\n  return model;\n}\n\n\n// NEW for lab 2 2012\n\nvoid DrawModel(Model *m)\n{\n\tGLuint program = m->program;\n\t// VBO for vertex data\n\tglBindBuffer(GL_ARRAY_BUFFER, m->vb);\n\tglVertexAttribPointer(glGetAttribLocation(program, \"inPosition\"), 3, GL_FLOAT, GL_FALSE, 0, 0); \n\tglEnableVertexAttribArray(glGetAttribLocation(program, \"inPosition\"));\n\t// VBO for normal data\n\tglBindBuffer(GL_ARRAY_BUFFER, m->nb);\n\tglVertexAttribPointer(glGetAttribLocation(program, \"inNormal\"), 3, GL_FLOAT, GL_FALSE, 0, 0); \n\tglEnableVertexAttribArray(glGetAttribLocation(program, \"inNormal\"));\n\t// VBO for texture coordinate data\n\tif (m->texCoordArray != NULL && false)\n\t{\n\t\tglBindBuffer(GL_ARRAY_BUFFER, m->tb);\n\t\tglVertexAttribPointer(glGetAttribLocation(program, \"inTexCoord\"), 2, GL_FLOAT, GL_FALSE, 0, 0); \n\t\tglEnableVertexAttribArray(glGetAttribLocation(program, \"inTexCoord\"));\n\t}\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m->ib);\n\n\n\tglEnableVertexAttribArray(0);\n\tglDrawElements(GL_TRIANGLES, m->numIndices, GL_UNSIGNED_INT, 0L);\n}\n\nModel* LoadModelPlus(char* name,\n\t\t\tGLuint program,\n\t\t\tchar* vertexVariableName,\n\t\t\tchar* normalVariableName,\n\t\t\tchar* texCoordVariableName)\n{\n\tModel *m;\n\t\n\tm = LoadModel(name);\n\tm->program = program;\n\n\tglGenBuffers(1, &m->vb);\n\tglGenBuffers(1, &m->ib);\n\tglGenBuffers(1, &m->nb);\n\tif (m->texCoordArray != NULL && false)\n\t\tglGenBuffers(1, &m->tb);\n\t\n\n\t// VBO for vertex data\n\tglBindBuffer(GL_ARRAY_BUFFER, m->vb);\n\tglBufferData(GL_ARRAY_BUFFER, m->numVertices*3*sizeof(GLfloat), m->vertexArray, GL_STATIC_DRAW);\n\t//glVertexAttribPointer(glGetAttribLocation(program, vertexVariableName), 3, GL_FLOAT, GL_FALSE, 0, 0); \n\t//glEnableVertexAttribArray(glGetAttribLocation(program, vertexVariableName));\n\n\t// VBO for normal data\n\tglBindBuffer(GL_ARRAY_BUFFER, m->nb);\n\tglBufferData(GL_ARRAY_BUFFER, m->numVertices*3*sizeof(GLfloat), m->normalArray, GL_STATIC_DRAW);\n\t//glVertexAttribPointer(glGetAttribLocation(program, normalVariableName), 3, GL_FLOAT, GL_FALSE, 0, 0);\n\t//glEnableVertexAttribArray(glGetAttribLocation(program, normalVariableName));\n\t\n\t// VBO for texture coordinate data NEW for 5b\n\tif (m->texCoordArray != NULL && false)\n\t{\n\t\tglBindBuffer(GL_ARRAY_BUFFER, m->tb);\n\t\tglBufferData(GL_ARRAY_BUFFER, m->numVertices*2*sizeof(GLfloat), m->texCoordArray, GL_STATIC_DRAW);\n\t\t//glVertexAttribPointer(glGetAttribLocation(program, texCoordVariableName), 2, GL_FLOAT, GL_FALSE, 0, 0);\n\t\t//glEnableVertexAttribArray(glGetAttribLocation(program, texCoordVariableName));\n\t}\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m->ib);\n\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, m->numIndices*sizeof(GLuint), m->indexArray, GL_STATIC_DRAW);\n\n\n\t\n\treturn m;\n}\n","#include \"GL_utilities.h\"\n#include \"BunnyIsland.h\"\n#include \"VectorUtils2.h\"\n#include \"stdlib.h\"\n#include \"stdio.h\"\n#include \"math.h\"\n#include \"loadobj.h\"\n#include \"LoadTGA2.h\"\n#include \"BI_terrain.h\"\n#include \"BI_objects/BI_lightpost.h\"\n#include \"BI_objects/BI_player.h\"\n\n\n\n//Projection\n#define near 1.0\n#define far 500.0\n#define right 0.5\n#define left -0.5\n#define top 0.5\n#define bottom -0.5\n\n\nGLfloat projectionMatrix[16] = {    2.0f*near/(right-left), 0.0f, (right+left)/\t\t\t(right-left), 0.0f,0.0f, 2.0f*near/(top-bottom),\n (top+bottom)/(top-bottom), 0.0f,\n                                            0.0f, 0.0f, -(far + near)/(far - near), -2*far*near/(far - near),\n                                            0.0f, 0.0f, -1.0f, 0.0f };\n\nGLfloat tempMatrix[16] = {\t1.0f, 0.0f, 0.0f, 0.0f,\n\t\t                        0.0f, 1.0f, 0.0f, 0.0f,\n\t\t                        0.0f, 0.0f, 1.0f, 0.0f,\n\t\t                        0.0f, 0.0f, 0.0f, 1.0f };\n\nGLfloat translationMatrix[16] = {\t1.0f, 0.0f, 0.0f, 0.0f,\n\t\t                        0.0f, 1.0f, 0.0f, 0.0f,\n\t\t                        0.0f, 0.0f, 1.0f, 0.0f,\n\t\t                        0.0f, 0.0f, 0.0f, 1.0f };\n\n\nGLfloat rotationMatrix[16] = {\t1.0f, 0.0f, 0.0f, 0.0f,\n\t\t                        0.0f, 1.0f, 0.0f, 0.0f,\n\t\t                        0.0f, 0.0f, 1.0f, 0.0f,\n\t\t                        0.0f, 0.0f, 0.0f, 1.0f };\n\nGLfloat rotationMatrix2[16] = { 1.0f, 0.0f, 0.0f, 0.0f,\n\t\t\t\t0.0f, 1.0f, 0.0f, 0.0f,\n\t\t\t\t0.0f, 0.0f, 1.0f, 0.0f,\n\t\t\t\t0.0f, 0.0f, 0.0f, 1.0f };\n\nGLfloat transformationMatrix[16] = {\t1.0f, 0.0f, 0.0f, 0.0f,\n\t\t                        0.0f, 1.0f, 0.0f, 0.0f,\n\t\t                        0.0f, 0.0f, 1.0f, 0.0f,\n\t\t                        0.0f, 0.0f, 0.0f, 1.0f };\n\nGLfloat normalMatrix[9] = {\t0.0f,0.0f,0.0f,\n\t\t\t\t\t\t0.0f,0.0f,0.0f,\n\t\t\t\t\t\t0.0f,0.0f,0.0f };\n\n\n\n\tGLfloat mvMatrix[16] = {    1.0f, 0.0f, 0.0f, 0.0f,\n                        0.0f, 1.0f, 0.0f, 0.0f,\n                        0.0f, 0.0f, 1.0f, 0.0f,\n                        0.0f, 0.0f, 0.0f, 1.0f };\n\n\tGLfloat mvpMatrix[16] = {    1.0f, 0.0f, 0.0f, 0.0f,\n                        0.0f, 1.0f, 0.0f, 0.0f,\n                        0.0f, 0.0f, 1.0f, 0.0f,\n                        0.0f, 0.0f, 0.0f, 1.0f };\n\n\t\n\n\nGLint isReflection[1];\nconst GLfloat PI=3.14159265358f;\nGLfloat temp_x, temp_y, temp_z;\nGLint isWater[1], isText[1];\nGLuint program, tex_grass, tex_dirt, tex_sky, tex_orc, tex_water, tex_sand, tex_arrow, tex_bunny, tex_grenbox;\nTextureData height_map,water_map;\nModel *wind_balc, *ground, *wind_roof, *wind_wall, *wind_blade, *castle_wall, *castle_roof, *tree, *bunnymodel, *skybox, *arrowmodel, *water, *lightpostmodel, *orcmodel, *grenboxmodel;\n\nPoint3D lightSourcesDirectionsPositions[numLightsources];\nPoint3D lightSourcesColorsArr[numLightsources];\n\n\nGLfloat getGroundHeight(GLfloat x, GLfloat z)\n{\n\treturn getHeightValue(x,z,ground);\n}\nvoid initDraw(void) {\n\t\t// GL inits\nprintf(\"BI_draw init\");\n\tglClearColor(0.6,0.6,0.6,0);\n\tglEnable(GL_DEPTH_TEST);\n\tglCullFace(GL_BACK);\n\tglEnable(GL_CULL_FACE);\n\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\tglEnable( GL_BLEND );\n\n\tprintError(\"GL inits\");\n\n\n\t// Load and compile shader\n\t#if EMSCRIPTEN\n\tprogram = loadShaders(\"BunnyIsland.vert\", \"BunnyIsland.frag\");\n\t#else\n\tprogram = loadShaders(\"BunnyIsland_PC.vert\", \"BunnyIsland_PC.frag\");\n\t#endif\n\n\tLoadTGATexture(\"textures/fft-terrain.tga\", &height_map);\n\tLoadTGATexture(\"textures/water-terrain.tga\", &water_map);\n\tLoadTGATextureSimple(\"textures/ground_grass.tga\", &tex_grass);\n\tLoadTGATextureSimple(\"textures/dirt.tga\", &tex_dirt);\n\tLoadTGATextureSimple(\"textures/SkyBox512.tga\", &tex_sky);\n\tLoadTGATextureSimple(\"textures/OrcMale_Body.tga\", &tex_orc);\n\tLoadTGATextureSimple(\"textures/water.tga\", &tex_water);\n\tLoadTGATextureSimple(\"textures/sand.tga\", &tex_sand);\n \tLoadTGATextureSimple(\"textures/grenbox.tga\", &tex_grenbox);\n\tLoadTGATextureSimple(\"textures/bunny.tga\", &tex_bunny);\n\tglUniform1i(glGetUniformLocation(program, \"texUnit\"), 0);\n\tglUniform1i(glGetUniformLocation(program, \"texUnit2\"), 1);\n\t\n\tprintError(\"init shader\");\n\n\n\n\n\twind_wall = LoadModelPlus(\"3d_objects/windmill/windmill-walls.obj\", program,\"inPosition\",\"inNormal\",\"inTexCoord\"); \n\n\twind_balc = LoadModelPlus(\"3d_objects/windmill/windmill-balcony.obj\", program,\"inPosition\",\"inNormal\",\"inTexCoord\"); \n\n\twind_roof = LoadModelPlus(\"3d_objects/windmill/windmill-roof.obj\", program,\"inPosition\",\"inNormal\",\"inTexCoord\"); \n\n\twind_blade = LoadModelPlus(\"3d_objects/windmill/blade.obj\", program,\"inPosition\",\"inNormal\",\"inTexCoord\"); \n\n\tground = GenerateTerrain(&height_map, program, \"inPosition\",\"inNormal\",\"inTexCoord\");\n\n\n\twater = GenerateTerrain(&water_map, program, \"inPosition\",\"inNormal\",\"inTexCoord\");//LoadModelPlus(\"3d_objects/water.obj\", program,\"inPosition\",\"inNormal\",\"inTexCoord\");\n\tcastle_wall = LoadModelPlus(\"3d_objects/castle/walls.obj\", program,\"inPosition\",\"inNormal\",\"inTexCoord\");\n\tcastle_roof = LoadModelPlus(\"3d_objects/castle/rooftops.obj\", program,\"inPosition\",\"inNormal\",\"inTexCoord\");\n\tbunnymodel = LoadModelPlus(\"3d_objects/bunnyplus.obj\", program,\"inPosition\",\"inNormal\",\"inTexCoord\");\n\tarrowmodel = LoadModelPlus(\"3d_objects/arrow.obj\", program,\"inPosition\",\"inNormal\",\"inTexCoord\");\n\torcmodel = LoadModelPlus(\"3d_objects/OrcMale.obj\", program,\"inPosition\",\"inNormal\",\"inTexCoord\");\n\tlightpostmodel = LoadModelPlus(\"3d_objects/lightpost.obj\", program,\"inPosition\",\"inNormal\",\"inTexCoord\");\n\tskybox = LoadModelPlus(\"3d_objects/skybox.obj\", program,\"inPosition\",\"inNormal\",\"inTexCoord\");\n\tgrenboxmodel = LoadModelPlus(\"3d_objects/grenbox.obj\", program,\"inPosition\",\"inNormal\",\"inTexCoord\");\n\n\t\n\tprintError(\"init arrays\");\n\n\n\t\n\tGLfloat x, z;\n\tx = 444.0; z = 576.0;\n\tlpArray[0] = CreateLightpost(x,getGroundHeight(x,z),z);\n\tx = 284.0; z = 488.0;\n\tlpArray[1] = CreateLightpost(x,getGroundHeight(x,z),z);\n\tx = 370.0; z = 360.0;\n\tlpArray[2] = CreateLightpost(x,getGroundHeight(x,z),z);\n\tx = 493.0; z = 279.0;\n\tlpArray[3] = CreateLightpost(x,getGroundHeight(x,z),z);\n\tx = 638.0; z = 259.0;\n\tlpArray[4] = CreateLightpost(x,getGroundHeight(x,z),z);\n\tx = 663.0; z = 452.0;\n\tlpArray[5] = CreateLightpost(x,getGroundHeight(x,z),z);\n\tx = 407.0; z = 666.0;\n\tlpArray[6] = CreateLightpost(x,getGroundHeight(x,z),z);\n\tx = 491.0; z = 669.0;\n\tlpArray[7] = CreateLightpost(x,getGroundHeight(x,z),z);\n\n\n\tfor(int i=0;i<numLightsources;i++)\n\t{\n\t\tPoint3D pos = {lpArray[i]->x, lpArray[i]->y+12, lpArray[i]->z};\n\t\tlightSourcesDirectionsPositions[i] = pos;\n\t\tPoint3D white = {1.0, 1.0, 1.0};\n\t\tlightSourcesColorsArr[i] = white;\n\t}\n\n\n\t// Lighting colors\n\tglUniform3fv(glGetUniformLocation(program, \"lightSourcesDirPosArr\"), numLightsources, &lightSourcesDirectionsPositions[0].x);\n\tglUniform3fv(glGetUniformLocation(program, \"lightSourcesColorArr\"), numLightsources, &lightSourcesColorsArr[0].x);\n\tglUniformMatrix3fv(glGetUniformLocation(program, \"normalMatrix\"), 1, GL_FALSE, normalMatrix);\n\n}\n\n\nvoid uploadMatrices(int reflect) {\n\tif(reflect)\n\t{\n\t\n\tisReflection[0] = 1;\n\t\n\tGLfloat reflectionMatrix[16] = {\t1.0f, 0.0f, 0.0f, 0.0f,\n\t\t                        0.0f, -1.0f, 0.0f, 5.0f,\n\t\t                        0.0f, 0.0f, 1.0f, 0.0f,\n\t\t                        0.0f, 0.0f, 0.0f, 1.0f };\n\tGLfloat bufferMatrix[16] = {\t1.0f, 0.0f, 0.0f, 0.0f,\n\t\t                        0.0f, 1.0f, 0.0f, 0.0f,\n\t\t                        0.0f, 0.0f, 1.0f, 0.0f,\n\t\t                        0.0f, 0.0f, 0.0f, 1.0f };\n\tMult(reflectionMatrix,transformationMatrix,bufferMatrix);\n\tMult(cameraMatrix,bufferMatrix,mvMatrix);\n\tMult(projectionMatrix,mvMatrix,mvpMatrix);\n\t}\n\telse \n\t{\n\t\tisReflection[0] = 0;\n\t\tMult(cameraMatrix,transformationMatrix,mvMatrix);\n\t\tMult(projectionMatrix,mvMatrix,mvpMatrix);\n\t}\n\tglUniform1f(glGetUniformLocation(program, \"time\"),  tid);\n\tCalcNormalMatrix(mvMatrix, normalMatrix);\n\tglUniform1iv(glGetUniformLocation(program, \"isReflection\"), 1, isReflection);\n\tglUniform1i(glGetUniformLocation(program, \"activeLightsources\"), activeLightsources);\n\tglUniformMatrix4fv(glGetUniformLocation(program, \"cameraMatrix\"), 1, GL_FALSE, cameraMatrix);\n\tglUniformMatrix4fv(glGetUniformLocation(program, \"mvpMatrix\"), 1, GL_FALSE, mvpMatrix);\n\tglUniformMatrix4fv(glGetUniformLocation(program, \"mvMatrix\"), 1, GL_FALSE, mvMatrix);\n\tglUniformMatrix4fv(glGetUniformLocation(program, \"mMatrix\"), 1, GL_FALSE, transformationMatrix);\n\tglUniformMatrix3fv(glGetUniformLocation(program, \"normalMatrix\"), 1, GL_FALSE, normalMatrix);\n}\n\n\nvoid drawWindmill(GLfloat x, GLfloat y, GLfloat z, int reflect) {\n\tglUniform1f(glGetUniformLocation(program, \"playerY\"),  player->y); // fulkod!!\n\n\tglActiveTexture(GL_TEXTURE1);\n\tglBindTexture(GL_TEXTURE_2D, tex_dirt);\n\tglActiveTexture(GL_TEXTURE0);\n\tglBindTexture(GL_TEXTURE_2D, tex_dirt);\n\n\tT(x, y, z, translationMatrix);\n\tIdentityMatrix(rotationMatrix);\n\tMult(translationMatrix,rotationMatrix,transformationMatrix);\n\tuploadMatrices(reflect);\n\tDrawModel(wind_wall);\n\tDrawModel(wind_roof);\n\tDrawModel(wind_balc);\n\t//Windmill blades\n\tGLfloat timerotationterm = (float)tid/1800.0;\n\n\tT(x+4.6f, y+9.1f, z+0.0f, translationMatrix);\n\ttranslationMatrix[0] = 0.8 ; translationMatrix[5] = 0.8 ; translationMatrix[10] = 0.8 ;\n\tRx(timerotationterm, rotationMatrix);\n\tMult(translationMatrix,rotationMatrix,transformationMatrix);\n\tuploadMatrices(reflect);\n\tDrawModel(wind_blade);\n\n\n\tRx(3.14+timerotationterm, rotationMatrix);\n\tMult(translationMatrix,rotationMatrix,transformationMatrix);\n\tuploadMatrices(reflect);\n\tDrawModel(wind_blade);\n\n\n\tRx(3*3.14/2+timerotationterm, rotationMatrix);\n\tMult(translationMatrix,rotationMatrix,transformationMatrix);\n\tuploadMatrices(reflect);\n\n\tDrawModel(wind_blade);\n\n\n\tRx(3.14/2+timerotationterm, rotationMatrix);\n\tMult(translationMatrix,rotationMatrix,transformationMatrix);\n\tuploadMatrices(reflect);\n\n\tDrawModel(wind_blade);\n}\n\n\nvoid drawCastle(GLfloat x,GLfloat y, GLfloat z, int reflect) {\n\tglActiveTexture(GL_TEXTURE1);\n\tglBindTexture(GL_TEXTURE_2D, tex_dirt);\n\tglActiveTexture(GL_TEXTURE0);\n\tglBindTexture(GL_TEXTURE_2D, tex_dirt);\n\tT(x, y, z, translationMatrix);\n\tIdentityMatrix(rotationMatrix);\n\ttranslationMatrix[0] = 0.1 ; translationMatrix[5] = 0.1 ; translationMatrix[10] = 0.1 ;\n\tMult(translationMatrix,rotationMatrix,transformationMatrix);\n\tuploadMatrices(reflect);\n\tDrawModel(castle_wall);\n\tDrawModel(castle_roof);\n}\n\nvoid drawBunny(GLfloat x,GLfloat y, GLfloat z, GLfloat ry, int reflect) {\n\tglActiveTexture(GL_TEXTURE1);\n\tglBindTexture(GL_TEXTURE_2D, tex_bunny);\n\tglActiveTexture(GL_TEXTURE0);\n\tglBindTexture(GL_TEXTURE_2D, tex_bunny);\n\tT(x, y, z, translationMatrix);\n\tRy(ry+PI,rotationMatrix);\n\tMult(translationMatrix,rotationMatrix,transformationMatrix);\n\tuploadMatrices(reflect);\n\tDrawModel(bunnymodel);\n}\n\nvoid drawGrenbox(GLfloat x,GLfloat y, GLfloat z, GLfloat ry, int reflect) {\n\tglActiveTexture(GL_TEXTURE1);\n\tglBindTexture(GL_TEXTURE_2D, tex_grenbox);\n\tglActiveTexture(GL_TEXTURE0);\n\tglBindTexture(GL_TEXTURE_2D, tex_grenbox);\n\tT(x, y+2.0f, z, translationMatrix);\n\ttranslationMatrix[0] = 2.0f ; translationMatrix[5] = 2.0f ; translationMatrix[10] = 2.0f ;\n\tRy(ry+PI,rotationMatrix);\n\tMult(translationMatrix,rotationMatrix,transformationMatrix);\n\tuploadMatrices(reflect);\n\tDrawModel(grenboxmodel);\n}\n\n\nvoid drawOrc(GLfloat x,GLfloat y, GLfloat z, GLfloat ry, GLfloat size, int reflect) {\n\tglActiveTexture(GL_TEXTURE1);\n\tglBindTexture(GL_TEXTURE_2D, tex_orc);\n\tglActiveTexture(GL_TEXTURE0);\n\tglBindTexture(GL_TEXTURE_2D, tex_orc);\n\tT(x, y, z, translationMatrix);\n\ttranslationMatrix[0] = size ; translationMatrix[5] = size ; translationMatrix[10] = size;\n\n\tRy(ry+PI,rotationMatrix);\n\tMult(translationMatrix,rotationMatrix,transformationMatrix);\n\tuploadMatrices(reflect);\n\tDrawModel(orcmodel);\n}\n\nvoid drawSky(void) {\n\tglDisable(GL_DEPTH_TEST);\n\tglDisable(GL_CULL_FACE);\n\tglActiveTexture(GL_TEXTURE1);\n\tglBindTexture(GL_TEXTURE_2D, tex_sky);\n\tglActiveTexture(GL_TEXTURE0);\n\tglBindTexture(GL_TEXTURE_2D, tex_sky);\n\tIdentityMatrix(transformationMatrix);\n\ttemp_x = cameraMatrix[3];\n\ttemp_y = cameraMatrix[7];\n\ttemp_z = cameraMatrix[11];\n\tcameraMatrix[3] = 0.0\t;\n\tcameraMatrix[7] = 0.0;\n\tcameraMatrix[11] = 0.0;\n\tuploadMatrices(0);\n\tDrawModel(skybox);\n\tglEnable(GL_DEPTH_TEST);\n\tglCullFace(GL_BACK);\n\tglEnable(GL_CULL_FACE);\n\tcameraMatrix[3] = temp_x;\n\tcameraMatrix[7] = temp_y;\n\tcameraMatrix[11] = temp_z;\t\n\tuploadMatrices(0);\n}\n\nvoid drawWater(void) {\n\tglDisable(GL_CULL_FACE);\n\tT(0.0, -6.033333, 0.0, translationMatrix);\n\tIdentityMatrix(rotationMatrix);\n\tMult(translationMatrix,rotationMatrix,transformationMatrix);\n\tglActiveTexture(GL_TEXTURE1);\n\tglBindTexture(GL_TEXTURE_2D, tex_water);\n\tglActiveTexture(GL_TEXTURE0);\n\tglBindTexture(GL_TEXTURE_2D, tex_water);\n\tisWater[0] = 1;\n\tglUniform1iv(glGetUniformLocation(program, \"isWater\"), 1, isWater);\n\tuploadMatrices(0);\n\tDrawModel(water);\n\tisWater[0] = 0;\n\tglUniform1iv(glGetUniformLocation(program, \"isWater\"), 1, isWater);\n\tglCullFace(GL_BACK);\n\tglEnable(GL_CULL_FACE);\n\n}\n\nvoid drawGround(int reflect) {\n\tIdentityMatrix(transformationMatrix);\n\tglActiveTexture(GL_TEXTURE1);\n\tglBindTexture(GL_TEXTURE_2D, tex_sand);\n\tglActiveTexture(GL_TEXTURE0);\n\tglBindTexture(GL_TEXTURE_2D, tex_grass);\n\tuploadMatrices(reflect);\n\tDrawModel(ground);\n}\n\n\n\n\nvoid drawText(GLfloat posX, GLfloat posY, char* string) {\n\tglDisable(GL_DEPTH_TEST);\n\tisText[0] = 1;\n\tglUniform1iv(glGetUniformLocation(program, \"isText\"), 1, isText);\t\n\tglUniformMatrix4fv(glGetUniformLocation(program, \"cameraMatrix\"), 1, GL_FALSE, tempMatrix);\n\tglUniformMatrix4fv(glGetUniformLocation(program, \"mvpMatrix\"), 1, GL_FALSE, tempMatrix);\n\tglUniformMatrix4fv(glGetUniformLocation(program, \"mvMatrix\"), 1, GL_FALSE, tempMatrix);\n\tglUniformMatrix4fv(glGetUniformLocation(program, \"mMatrix\"), 1, GL_FALSE, tempMatrix);\n\tglUniformMatrix3fv(glGetUniformLocation(program, \"normalMatrix\"), 1, GL_FALSE, tempMatrix);\n\t//glRasterPos2f(posX, posY); need workaround\n\tfor(int i=0;i<strlen(string); i++)\n\t{\n\t\tglutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, string[i]);\n\t}\n\tisText[0] = 0;\n\tglUniform1iv(glGetUniformLocation(program, \"isText\"), 1, isText);\n\tglEnable(GL_DEPTH_TEST);\n}\n\nvoid drawLightpost(GLfloat x, GLfloat z, int reflect) {\n\tglActiveTexture(GL_TEXTURE1);\n\tglBindTexture(GL_TEXTURE_2D, tex_sand);\n\tglActiveTexture(GL_TEXTURE0);\n\tglBindTexture(GL_TEXTURE_2D, tex_sand);\n\tT(x, getHeightValue(x,z, ground), z, translationMatrix);\n\ttranslationMatrix[0] = 0.007 ; translationMatrix[5] = 0.007; translationMatrix[10] = 0.007;\n\n\tIdentityMatrix(rotationMatrix);\n\tMult(translationMatrix,rotationMatrix,transformationMatrix);\n\tuploadMatrices(reflect);\n\tDrawModel(lightpostmodel);\n}\n\nvoid drawArrow(GLfloat x, GLfloat y, GLfloat z, GLfloat ry, GLfloat rz, int reflect) {\n\tglActiveTexture(GL_TEXTURE1);\n\tglBindTexture(GL_TEXTURE_2D, tex_sand);\n\tglActiveTexture(GL_TEXTURE0);\n\tglBindTexture(GL_TEXTURE_2D, tex_sand);\n\tT(x, y, z, translationMatrix);\n\ttranslationMatrix[0] = 10.1 ; translationMatrix[5] = 10.1 ; translationMatrix[10] = 10.1 ;\n\tRy(PI/2+ry,rotationMatrix);\n\tRz(rz,rotationMatrix2);\n\tMult(rotationMatrix, rotationMatrix2, rotationMatrix);\n\t\n\t//arrow points in -x by default\n\t//ry is rotation around y axis, 0 is z\n\tMult(translationMatrix,rotationMatrix,transformationMatrix);\n\tuploadMatrices(reflect);\n\tDrawModel(arrowmodel);\n}\n\nint isValidPoint(GLfloat x, GLfloat z) {\n\t// if(getHeightValue(x,z,ground) < 3.0) return false; // removed to simplify bunny AI\n\tif(x<200 || x>830 || z<190 || z >850) return false; // if in the ocean\n\treturn true;\n\n}\n\n","#include \"BI_terrain.h\"\n#include \"VectorUtils2.h\"\n\nint terrainWidth, terrainHeight;\n#define scale 0.5\n#define heightScale 15.0\n\nint isValidPointTerrain(GLfloat x, GLfloat z) {\n\treturn (scale*x<1 || scale*x>terrainWidth-1 || scale*z<1 || scale*z>(terrainHeight-1)) ? 0:1;\n}\n\n\nGLfloat getHeightValue(GLfloat x, GLfloat z, Model* tm)\n{\n\tGLfloat y = 0.0;\n\tPoint3D normal;\n\t// Triangle 1\n\tif(scale*x<1 || scale*x>terrainWidth-1 || scale*z<1 || scale*z>(terrainHeight-1)) return 0.0;\n\tint x_scaled = (int)x * scale;\n\tint z_scaled = (int)z * scale;\n\tint i = ( x_scaled + z_scaled * (terrainWidth-1))*6; // index of first vertex of triangle 1 in current quad in index array\n\tint vertex_x = tm->vertexArray[(tm->indexArray[i])*3];\t\n\tint vertex_y = tm->vertexArray[(tm->indexArray[i])*3+1];\t\n\tint vertex_z = tm->vertexArray[(tm->indexArray[i])*3+2];\n\tif((x-vertex_x) + (z-vertex_z) <= 1)\n{// triangel 1\n\t\t\n\t\t\t//vektor 1 för triangle 1:\n\t\t\tPoint3D p1;\n\t\t\t//printf(\"%d är %d\",(tm->indexArray[i])*3,3*(vertex_x+vertex_z*terrainWidth));\n\t\t\tp1.x = tm->vertexArray[(tm->indexArray[i+1])*3 +0]- tm->vertexArray[(tm->indexArray[i])*3 +0];\n\t\t\tp1.y = tm->vertexArray[(tm->indexArray[i+1])*3 +1] - tm->vertexArray[(tm->indexArray[i])*3 +1];\n\t\t\tp1.z = tm->vertexArray[(tm->indexArray[i+1])*3 +2] - tm->vertexArray[(tm->indexArray[i])*3 +2];\n\n\t\t\t//vektor 2 för triangle 1:\n\t\t\tPoint3D p2;\n\t\t\tp2.x = tm->vertexArray[(tm->indexArray[i+2])*3 +0] - tm->vertexArray[(tm->indexArray[i])*3 +0];\n\t\t\tp2.y = tm->vertexArray[(tm->indexArray[i+2])*3 +1] - tm->vertexArray[(tm->indexArray[i])*3 +1];\n\t\t\tp2.z = tm->vertexArray[(tm->indexArray[i+2])*3 +2] - tm->vertexArray[(tm->indexArray[i])*3 +2];\n\n\n\t\t\t//Normal for triangle 1:\n\n\t\t\tCrossProduct(&p2,&p1,&normal);\n\t\t\tNormalize(&normal);\n\n\n\t}\n\n\telse if((x-vertex_x) + (z-vertex_z) > 1)\n{\t// triangel 2 \n\t\t//\tprintf(\"TRIANGEL 2\\n\");\n\t\t\t//vektor 1 för triangle 1:\n\t\t\tPoint3D p1;\n\t\t\t//printf(\"%d är %d\",(tm->indexArray[i])*3,3*(vertex_x+vertex_z*terrainWidth));\n\t\t\tp1.x = tm->vertexArray[(tm->indexArray[i+3])*3 +0]- tm->vertexArray[(tm->indexArray[i+5])*3 +0];\n\t\t\tp1.y = tm->vertexArray[(tm->indexArray[i+3])*3 +1] - tm->vertexArray[(tm->indexArray[i+5])*3 +1];\n\t\t\tp1.z = tm->vertexArray[(tm->indexArray[i+3])*3 +2] - tm->vertexArray[(tm->indexArray[i+5])*3 +2];\n\n\t\t\t//vektor 2 för triangle 1:\n\t\t\tPoint3D p2;\n\t\t\tp2.x = tm->vertexArray[(tm->indexArray[i+4])*3 +0] - tm->vertexArray[(tm->indexArray[i+5])*3 +0];\n\t\t\tp2.y = tm->vertexArray[(tm->indexArray[i+4])*3 +1] - tm->vertexArray[(tm->indexArray[i+5])*3 +1];\n\t\t\tp2.z = tm->vertexArray[(tm->indexArray[i+4])*3 +2] - tm->vertexArray[(tm->indexArray[i+5])*3 +2];\n\n\n\t\t\t//Normal for triangle 1:\n\n\t\t\tCrossProduct(&p2,&p1,&normal);\n\t\t\tNormalize(&normal);\n\n}\n\n\n\nelse return -1; // UNDEFINED\n\n\t\t\tGLfloat d_plane;\n\t\t\td_plane = normal.x*vertex_x + normal.y*vertex_y + normal.z*vertex_z;\n\t\t\ty = -(normal.x*x + normal.z*z - d_plane)/normal.y;\n\n\n\n\treturn y;\n}\n\n\nModel* GenerateTerrain(TextureData *tex,\n GLuint program,\n char* vertexVariableName,\n char* normalVariableName,\n char* texCoordVariableName)\n{\n\tint vertexCount = tex->width * tex->height;\n\tint triangleCount = (tex->width-1) * (tex->height-1) * 2;\n\tint x, z;\n\n\tterrainWidth = tex->width;\n\tterrainHeight = tex->height;\n\t\n\tModel* model = malloc(sizeof(Model));\n\tmemset(model, 0, sizeof(Model));\n\t\n\tmodel->vertexArray = malloc(sizeof(Model));\n\t\n\tmodel->vertexArray = malloc(sizeof(GLfloat) * 3 * vertexCount);\n\tmodel->normalArray = malloc(sizeof(GLfloat) * 3 * vertexCount);\n\tmodel->texCoordArray = malloc(sizeof(GLfloat) * 2 * vertexCount);\n\tmodel->indexArray = malloc(sizeof(GLuint) * triangleCount*3);\n\t\n\tmodel->numVertices = vertexCount;\n\tmodel->numIndices = triangleCount*3;\n\t\n\tfor (x = 0; x < tex->width; x++)\n\t\tfor (z = 0; z < tex->height; z++)\n\t\t{\n// Vertex array. You need to scale this properly\n\t\t\tmodel->vertexArray[(x + z * tex->width)*3 + 0] = x / scale;\n\t\t\tmodel->vertexArray[(x + z * tex->width)*3 + 1] = tex->imageData[(x + z * tex->width) * (tex->bpp/8)] / heightScale;\n\t\t//\tprintf(\"y: %f \\n\",tex->imageData[(x + z * tex->width) * (tex->bpp/8)] / heightScale);\n\t\t\tmodel->vertexArray[(x + z * tex->width)*3 + 2] = z / scale;\n// Normal vectors. You need to calculate these.\n\t\t\tmodel->normalArray[(x + z * tex->width)*3 + 0] = 0.0;\n\t\t\tmodel->normalArray[(x + z * tex->width)*3 + 1] = 0.0;\n\t\t\tmodel->normalArray[(x + z * tex->width)*3 + 2] = 0.0;\n// Texture coordinates. You may want to scale them.\n\t\t\tmodel->texCoordArray[(x + z * tex->width)*2 + 0] = x/10.0; // (float)x / tex->width;\n\t\t\tmodel->texCoordArray[(x + z * tex->width)*2 + 1] = z/10.0; // (float)z / tex->height;\n\t\t}\n\tfor (x = 0; x < tex->width-1; x++)\n\t\tfor (z = 0; z < tex->height-1; z++)\n\t\t{\n\n\t\t\t\n\t\t// Triangle 1\n\t\t\tmodel->indexArray[(x + z * (tex->width-1))*6 + 0] = x + z * tex->width;\n\t\t\tmodel->indexArray[(x + z * (tex->width-1))*6 + 1] = x + (z+1) * tex->width;\n\t\t\tmodel->indexArray[(x + z * (tex->width-1))*6 + 2] = x+1 + z * tex->width;\n\n\t\t// Triangle 2\n\t\t\tmodel->indexArray[(x + z * (tex->width-1))*6 + 3] = x+1 + z * tex->width;\n\t\t\tmodel->indexArray[(x + z * (tex->width-1))*6 + 4] = x + (z+1) * tex->width;\n\t\t\tmodel->indexArray[(x + z * (tex->width-1))*6 + 5] = x+1 + (z+1) * tex->width;\n\n\t\t\t//vektor 1 för triangle 1:\n\t\t\tPoint3D p1;\n\t\t\tp1.x = model->vertexArray[3*(x+1+z*tex->width) +0]- model->vertexArray[3*(x+z*tex->width) +0];\n\t\t\tp1.y = model->vertexArray[3*(x+1+z*tex->width) +1] - model->vertexArray[3*(x+z*tex->width) +1];\n\t\t\tp1.z = model->vertexArray[3*(x+1+z*tex->width) +2] - model->vertexArray[3*(x+z*tex->width) +2];\n\n\t\t\t//vektor 2 för triangle 1:\n\t\t\tPoint3D p2;\n\t\t\tp2.x = model->vertexArray[3*(x+(z+1)*tex->width)] - model->vertexArray[3*(x+z*tex->width) +0];\n\t\t\tp2.y = model->vertexArray[3*(x+(z+1)*tex->width) +1] - model->vertexArray[3*(x+z*tex->width) +1];\n\t\t\tp2.z = model->vertexArray[3*(x+(z+1)*tex->width) +2] - model->vertexArray[3*(x+z*tex->width) +2];\n\n\n\t\t\t//Normal for triangle 1:\n\t\t\tPoint3D normal;\n\t\t\tCrossProduct(&p2,&p1,&normal);\n\t\t\tNormalize(&normal);\n\n\t\t\t//printf(\"vektor p1: (%f,%f,%f)\", p1.x,p1.y,p1.z);\n\n\n\n\t\t\t//Triangle 1 vertex 1\n\t\t\tmodel->normalArray[3*(x + z * tex->width) + 0] += normal.x;\n\t\t\tmodel->normalArray[3*(x + z * tex->width) + 1] += normal.y;\n\t\t\tmodel->normalArray[3*(x + z * tex->width) + 2] += normal.z;\n\t\t\t//Triangle 1 vertex 2\n\t\t\tmodel->normalArray[3*(x + (z+1) * tex->width) + 0] += normal.x;\n\t\t\tmodel->normalArray[3*(x + (z+1) * tex->width) + 1] += normal.y;\n\t\t\tmodel->normalArray[3*(x + (z+1) * tex->width) + 2] += normal.z;\n\t\t\t//Triangle 1 vertex 3\n\t\t\tmodel->normalArray[3*(x+1 + z * tex->width) + 0] += normal.x;\n\t\t\tmodel->normalArray[3*(x+1 + z * tex->width) + 1] += normal.y;\n\t\t\tmodel->normalArray[3*(x+1 + z * tex->width) + 2] += normal.z;\n\n\n\t\t\t//vektor 1 för triangle 2:\n\t\t\tp1.x = model->vertexArray[3*(x+1 + z * tex->width)] - model->vertexArray[3*(x+1 + (z+1) * tex->width)];\n\t\t\tp1.y = model->vertexArray[3*(x+1 + z * tex->width) +1] - model->vertexArray[3*(x+1 + (z+1) * tex->width) +1];\n\t\t\tp1.z = model->vertexArray[3*(x+1 + z * tex->width) +2] - model->vertexArray[3*(x+1 + (z+1) * tex->width) +2];\n\n\t\t\t//vektor 2 för triangle 2\n\t\t\tp2.x = model->vertexArray[3*(x+(z+1)*tex->width)] - model->vertexArray[3*(x+1 + (z+1) * tex->width)];\n\t\t\tp2.y = model->vertexArray[3*(x+(z+1)*tex->width) +1] - model->vertexArray[3*(x+1 + (z+1) * tex->width) +1];\n\t\t\tp2.z = model->vertexArray[3*(x+(z+1)*tex->width) +2] - model->vertexArray[3*(x+1 + (z+1) * tex->width) +2];\n\n\t\t\t//Normal for triangle 2:\n\t\t\tCrossProduct(&p1,&p2,&normal);\n\t\t\tNormalize(&normal);\n\t\t\t//printf(\"%f \\n\",normal.z);\n\t\t\t\n\t\t\t//Triangle 2 vertex 1\n\t\t\tmodel->normalArray[3*(x+1 + z * tex->width) + 0] += normal.x;\n\t\t\tmodel->normalArray[3*(x+1 + z * tex->width) + 1] += normal.y;\n\t\t\tmodel->normalArray[3*(x+1 + z * tex->width) + 2] += normal.z;\n\t\t\t//Triangle 2 vertex 2\n\t\t\tmodel->normalArray[3*(x + (z+1) * tex->width) + 0] += normal.x;\n\t\t\tmodel->normalArray[3*(x + (z+1) * tex->width) + 1] += normal.y;\n\t\t\tmodel->normalArray[3*(x + (z+1) * tex->width) + 2] += normal.z;\n\t\t\t//Triangle 2 vertex 3\n\t\t\tmodel->normalArray[3*(x+1 + (z+1) * tex->width) + 0] += normal.x;\n\t\t\tmodel->normalArray[3*(x+1 + (z+1) * tex->width) + 1] += normal.y;\n\t\t\tmodel->normalArray[3*(x+1 + (z+1) * tex->width) + 2] += normal.z;\n\n\t\t}\n\t\n\tfor(int i=0;i<3 * vertexCount;i=i+3)\n\t{\n\t\t//printf(\"%f\",model->normalArray[i]);\n\t\tPoint3D normal;\n\t\tnormal.x = model->normalArray[i];\n\t\tnormal.y = model->normalArray[i+1];\n\t\tnormal.z = model->normalArray[i+2];\t\n\t\tNormalize(&normal);\n\t\tmodel->normalArray[i] = normal.x;\n\t\tmodel->normalArray[i+1] = normal.y;\n\t\tmodel->normalArray[i+2] = normal.z;\n\n\t\t//printf(\"normal: (%f,%f,%f)\\n\",normal.x,normal.y,normal.z);\n\t}\n\n\n\t// End of terrain generation\n\t\n\t// Upload and set variables like LoadModelPlus\n\t//glGenVertexArrays(1, &model->vao);\n\tglGenBuffers(1, &model->vb);\n\tglGenBuffers(1, &model->ib);\n\tglGenBuffers(1, &model->nb);\n\tif (model->texCoordArray != NULL)\n\t\tglGenBuffers(1, &model->tb);\n\t\n\t//glBindVertexArray(model->vao);\n\n\t// VBO for vertex data\n\tglBindBuffer(GL_ARRAY_BUFFER, model->vb);\n\tglBufferData(GL_ARRAY_BUFFER, model->numVertices*3*sizeof(GLfloat), model->vertexArray, GL_STATIC_DRAW);\n\tglVertexAttribPointer(glGetAttribLocation(program, vertexVariableName), 3, GL_FLOAT, GL_FALSE, 0, 0); \n\tglEnableVertexAttribArray(glGetAttribLocation(program, vertexVariableName));\n\n\t// VBO for normal data\n\tglBindBuffer(GL_ARRAY_BUFFER, model->nb);\n\tglBufferData(GL_ARRAY_BUFFER, model->numVertices*3*sizeof(GLfloat), model->normalArray, GL_STATIC_DRAW);\n\tglVertexAttribPointer(glGetAttribLocation(program, normalVariableName), 3, GL_FLOAT, GL_FALSE, 0, 0);\n\tglEnableVertexAttribArray(glGetAttribLocation(program, normalVariableName));\n\n\t// VBO for texture coordinate data\n\tif (model->texCoordArray != NULL)\n\t{\n\t\tglBindBuffer(GL_ARRAY_BUFFER, model->tb);\n\t\tglBufferData(GL_ARRAY_BUFFER, model->numVertices*2*sizeof(GLfloat), model->texCoordArray, GL_STATIC_DRAW);\n\t\tglVertexAttribPointer(glGetAttribLocation(program, texCoordVariableName), 2, GL_FLOAT, GL_FALSE, 0, 0);\n\t\tglEnableVertexAttribArray(glGetAttribLocation(program, texCoordVariableName));\n\t}\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, model->ib);\n\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, model->numIndices*sizeof(GLuint), model->indexArray, GL_STATIC_DRAW);\n\t\n\tmodel->program = program;\n\treturn model;\n}\n","#include \"GL_utilities.h\"\n#include \"BunnyIsland.h\"\n#include \"stdio.h\"\n\nGLfloat gravityTick(GLfloat *dy) {\n\tGLfloat ydiff = (dy[0]*ticktid/500 - 4.91*ticktid*ticktid/250000);\n\tdy[0] = dy[0] - 9.82*ticktid/500;\n\treturn ydiff;\n}\n","#include \"BI_player.h\"\n#include \"../BI_physics.h\"\n#include \"../BunnyIsland.h\"\n#include \"../BI_draw.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define height 2.0\n\nPlayer* CreatePlayer(void) {\n\tPlayer* player = malloc(sizeof(Player));\n\tmemset(player, 0, sizeof(Player));\n\tplayer->x = 0;\n\tplayer->y = 20;\n\tplayer->z = 0;\n\tplayer->ry = 0;\n\tplayer->dx = 0;\n\tplayer->dy = 0;\n\tplayer->dz = 0;\n\tplayer->hp = 0;\n\treturn player;\n}\nvoid TickPlayer(Player *p) {\n\tp->x = lookAtMatrix[0];\n\tp->z = lookAtMatrix[2];\n\t//printf(\"height: %f\\n\", p->y);\n\tGLfloat getheight = getGroundHeight(p->x,p->z)+height;\n\tif(lookAtMatrix[1]>getheight || p->dy>0.00001)\n\t{\n\t\tGLfloat change = gravityTick(&p->dy);\n\t\tlookAtMatrix[1]+= change;\n\t\tlookAtMatrix[4]+= change;\n\t}\n\telse\n\t{\t\t\n\t\tp->dy=0;\n\t\tGLfloat diff = getheight - lookAtMatrix[1];\n\t\tlookAtMatrix[1]+=diff;\n\t\tlookAtMatrix[4]+=diff;\n\t}\n\tp->y = lookAtMatrix[1];\n\n}\t\n","#include \"BI_bunny.h\"\n#include \"BI_arrow.h\"\n#include \"math.h\"\n#include \"../BI_physics.h\"\n#include \"../BunnyIsland.h\"\n#include \"../BI_draw.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n\nBunny* CreateBunny(void) {\n\tBunny* bunny = malloc(sizeof(Bunny));\n\tmemset(bunny, 0, sizeof(Bunny));\n\tbunny->x = 728.0f;\n\tbunny->y = 60;\n\tbunny->z = 253.0f;\n\tbunny->ry = 0;\n\tbunny->ds = 0.1f; //speed\n\tbunny->dy = 0;\n\tbunny->hp = 1;\n\treturn bunny;\n}\nvoid TickBunny(Bunny *b) {\n\n\tGLfloat getheight = getGroundHeight(b->x,b->z);\n\n\tif(b->hp > 0) {\n\t\tif(arrow->alive>0.5)\n\t\tif(arrow->x < b->x+1.0 && arrow->x > b->x-1.0 && arrow->y < b->y+2.0 && arrow->y > b->y-1.0 &&\tarrow->z < b->z+1.0 && arrow->z > b->z-1.0)\n\t\t{\n\t\t\tb->hp--;\n\t\t\tarrow->alive = 0.0f;\n\t\t}\n\t\tif(b->y > getheight || b->dy > 0.0001)\n\t\t{\n\t\t\tGLfloat change = gravityTick(&b->dy);\n\t\t\t//printf(\"bunny cos height: %f\\n\", cos(b->ry));\n\t\t\tb->y += change;\n\t\t\tGLfloat tempx = b->x + sin(b->ry)*b->ds*ticktid/17;\n\t\t\tGLfloat tempz = b->z - cos(b->ry)*b->ds*ticktid/17;\n\t\t\tif(isValidPoint(tempx,tempz)) {\n\t\t\t\tb->x = tempx;\n\t\t\t\tb->z = tempz;\n\t\t\t\t//inside castle;\n\t\t\t\tif((b->x > (CastleX-CastleHitBox)) && (b->x < (CastleX+CastleHitBox))\n\t\t\t\t\t\t && (b->z > (CastleZ-CastleHitBox)) && (b->z < (CastleZ+CastleHitBox))) {\n\t\t\t\t\tcastlehp--;\n\t\t\t\t\tb->x = orc->x;\t//should be orc position\n\t\t\t\t\tb->y = orc->y;\n\t\t\t\t\tb->z = orc->z;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\t//if(((rand()>>8)%2)) {\n\t\t\tGLfloat distance = 10000.0f;\n\t\t\tGLfloat tempdistance = 0.0f;\n\t\t\tGLfloat tempx;\n\t\t\tGLfloat tempz;\n\t\t\tGLfloat tempry;\n\t\t\tfor(int i=0;i<5;i++) {\n#ifdef __MINGW32__\n\t\t\t\ttempry = (rand() / (double)(RAND_MAX + 1) * (double)(2*3.14));\n#else\n\t\t\t\ttempry = (float)(((rand()>>8)%(2*314))/100.0f);\n#endif\n\t\t\t\ttempx = b->x + sin(tempry)*b->ds;\n\t\t\t\ttempz = b->z - cos(tempry)*b->ds;\n\t\t\t\tif(isValidPoint(tempx,tempz)) {\n\t\t\t\t\ttempdistance = sqrt((CastleX - tempx)*(CastleX - tempx) + (CastleZ - tempz)*(CastleZ - tempz));\n\t\t\t\t\tif(tempdistance < distance) {\n\t\t\t\t\t\tdistance = tempdistance;\n\n\t\t\t\t\t\tb->ry = tempry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\t//printf(\"bunny ry: %f\\n\", b->ry);\n\t\t\tb->dy = (float)(5.0f+(rand()>>8)%3);\n\t\t\tGLfloat diff = getheight - b->y;\n\t\t\tb->y+=diff;\n\n\t\t}\n\t}\n\telse {\n\t\tif(b->y > getheight || b->dy > 0.0001)\n\t\t{\n\t\t\tGLfloat change = gravityTick(&b->dy);\n\t\t\t//printf(\"bunny y height: %f %f\\n\", b->y, getheight);\n\t\t\tb->y += change;\n\t\t}\n\t\telse if(b->y != getheight) {\n\t\t\tb->y = getheight;\n\t\t}\n\t}\n\t//printf(\"height2: %f\\n\", getheight);\n\t//printf(\"height2: %f\\n\", b->y);\n\t//drawBunny(b->x, b->y+1.2f, b->z, b->ry, 0);\n}\t\n","#include \"BI_arrow.h\"\n#include \"../BI_physics.h\"\n#include \"../BunnyIsland.h\"\n#include \"../BI_draw.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define height 0.2\n#define speed 4.0\n\nArrow* CreateArrow(GLfloat x,GLfloat y,GLfloat z,GLfloat dx,GLfloat dy,GLfloat dz, GLfloat ry) {\n\tArrow* arrow = malloc(sizeof(Arrow));\n\tmemset(arrow, 0, sizeof(Arrow));\n\tarrow->x = x;\n\tarrow->y = y;\n\tarrow->z = z;\n\tarrow->ry = ry;\n\tarrow->dx = dx;\n\tarrow->dy = dy;\n\tarrow->dz = dz;\n\tarrow->alive = 1.0f;\n\treturn arrow;\n}\nvoid TickArrow(Arrow *p) {\n\tGLfloat getheight = getGroundHeight(p->x,p->z)+height;\n\t\t\n\tif(p->y<getheight || arrow->alive<0.5)\n\t{\n\t\tp->dx=0;\n\t\tp->dy=0;\n\t\tp->dz=0;\n\t\t\n\t}\n\n\telse\n\t{\n\t\tGLfloat changex, changey, changez; //vector between old coords and new coords\n\t\tchangex = p->dx*speed*ticktid/17;\n\t\tchangey = gravityTick(&p->dy);\n\t\tchangez = p->dz*speed*ticktid/17;\n\t\t\n\t\tp->rz = asin(-changey/(sqrt(changex*changex+changey*changey+changez*changez)));\n\t\t\n\t\tp->x += changex;\n\t\tp->y += changey;\n\t\tp->z += changez;\n\n\t}\n\t\t\n}\t\n","#include \"BI_lightpost.h\"\n#include \"../BI_physics.h\"\n#include \"../BunnyIsland.h\"\n#include \"../BI_draw.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define height 0.2\n#define speed 1.0\n\nLightpost* CreateLightpost(GLfloat x,GLfloat y,GLfloat z) {\n\tLightpost* lp = malloc(sizeof(Lightpost));\n\tmemset(lp, 0, sizeof(Lightpost));\n\tlp->x = x;\n\tlp->y = y;\n\tlp->z = z;\n\treturn lp;\n}\nvoid TickLightpost(Lightpost *p) {\n\t//drawLightpost(p->x, p->z, 0);\n\t\n}\t\n","#include \"BI_orc.h\"\n#include \"BI_arrow.h\"\n#include \"math.h\"\n#include \"../BI_physics.h\"\n#include \"../BunnyIsland.h\"\n#include \"../BI_draw.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define OrcSizeX 1.0\n#define OrcSizeY 2.0\n#define OrcSizeZ 1.0\n\n\n\nOrc* CreateOrc(void) {\n\tOrc* orc = malloc(sizeof(Orc));\n\tmemset(orc, 0, sizeof(Orc));\n\torc->x = OrcX;\n\torc->y = 60;\n\torc->z = OrcZ;\n\torc->ry = 0;\n\torc->ds = 0.1f; //speed\n\torc->dy = 0;\n\torc->hp = 100;\n\torc->size = 1.0f;\n\treturn orc;\n}\nvoid TickOrc(Orc *b) {\n\n\tGLfloat getheight = getGroundHeight(b->x,b->z);\n\n\tif(b->hp > 0) {\n\t\tif(arrow->alive>0.5)\n\t\tif(arrow->x < b->x+OrcSizeX*b->size && arrow->x > b->x-OrcSizeX*b->size && arrow->y < b->y+OrcSizeY*b->size && arrow->y > b->y-OrcSizeY*b->size && arrow->z < b->z+OrcSizeZ*b->size && arrow->z > b->z-OrcSizeZ*b->size)\n\t\t{\n\t\t\tb->hp--;\n\t\t\tb->ry+=3.14;\n\t\t\tarrow->alive=0.0f;\n\t\t}\n\t\tif(b->y > getheight || b->dy > 0.0001)\n\t\t{\n\t\t\tGLfloat change = gravityTick(&b->dy);\n\t\t\t//printf(\"Orc cos height: %f\\n\", cos(b->ry));\n\t\t\tb->y += change;\n\t\t\tGLfloat tempx = b->x + sin(b->ry)*b->ds*ticktid/17;\n\t\t\tGLfloat tempz = b->z - cos(b->ry)*b->ds*ticktid/17;\n\t\t\tif(isValidPoint(tempx,tempz)) {\n\t\t\t\tb->x = tempx;\n\t\t\t\tb->z = tempz;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tGLfloat tempx = b->x + sin(b->ry)*b->ds;\n\t\t\tGLfloat tempz = b->z - cos(b->ry)*b->ds;\n\t\t\tif(!isValidPoint(tempx,tempz)) {\n\t\t\t\tb->ry+=3.14;\n\t\t\t\t\n\t\t\t}\n\t\t\t\tb->ry += (float)(((rand()>>8)%(2*314))/1000.0f);\n\t\t\t\tb->ry -= (float)(((rand()>>8)%(2*314))/1000.0f);\n\t\t\t\t\n\t\t\t\t\n\t\t\tb->dy = (float)(5.0f+(rand()>>8)%3)+b->size;\n\t\t\tif(b->dy>40) b->dy = 40.0f;\n\t\t\tGLfloat diff = getheight - b->y;\n\t\t\tb->y+=diff;\n\n\t\t}\n\t}\n\telse {\n\t\tif(b->y > getheight || b->dy > 0.0001)\n\t\t{\n\t\t\tGLfloat change = gravityTick(&b->dy);\n\t\t\t//printf(\"Orc y height: %f %f\\n\", b->y, getheight);\n\t\t\tb->y += change;\n\t\t}\n\t\telse if(b->y != getheight) {\n\t\t\tb->y = getheight;\n\t\t}\n\t}\n\t//printf(\"height2: %f\\n\", getheight);\n\t//printf(\"height2: %f\\n\", b->y);\n\t//drawOrc(b->x, b->y, b->z, b->ry, b->size, 0);\n}\t\n","#include \"BI_grenbox.h\"\n#include \"BI_player.h\"\n#include \"BI_player.h\"\n#include \"../BI_physics.h\"\n#include \"../BunnyIsland.h\"\n#include \"../BI_draw.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define height 0.2\n#define speed 1.0\n\nGrenbox* CreateGrenbox() {\n\tGrenbox* grenbox = malloc(sizeof(Grenbox));\n\tmemset(grenbox, 0, sizeof(Grenbox));\n\tGLfloat tempx, tempz;\n\tdo{\n#ifdef __MINGW32__\n\t\ttempx = (double)rand() / (double)(RAND_MAX + 1) * (900 - 150)+ (double)150;\n\t\ttempz = (double)rand() / (double)(RAND_MAX + 1) * (900 - 150)+ (double)150;\n#else\n\t\ttempx = (float)((rand()>>8)%1000);\n\t\ttempz = (float)((rand()>>8)%1000);\n#endif\n\t}while(!isValidPoint(tempx,tempz));\n\tgrenbox->dy = 0.0f;\n\tgrenbox->x = tempx;\n\tgrenbox->y = 100.0f;\n\tgrenbox->z = tempz;\n\tgrenbox->ry = tempx;\n\tgrenbox->alive = 0.0f;\n\treturn grenbox;\n}\nvoid TickGrenbox(Grenbox *p) {\n\tif(p->alive>0.5)\n\t{\n\t\tGLfloat getheight = getGroundHeight(p->x,p->z)+height;\n\t\tif(player->x < p->x+2.0 && player->x > p->x-2.0 &&\tplayer->z < p->z+2.0 && player->z > p->z-2.0)\n\t\t{\n\t\t\tgrenades++;\n\t\t\tp->alive = 0.0f;\n\t\t}\n\t\tif(p->y<getheight)\n\t\t{\n\t\t\t\n\t\t}\n\n\t\telse\n\t\t{\n\t\t\tGLfloat change = gravityTick(&p->dy);\n\t\t\tp->y += change;\n\t\t}\n\t\n\t//\tdrawGrenbox(p->x,p->y,p->z, p->ry, 0);\n\t}\n\n\t\n}\t\n","// TGA loader, by Ingemar 2009, based on \"tga.c\" and some other sources.\n\n#include \"LoadTGA2.h\"\n\nbool LoadTGATextureData(char *filename, TextureData *texture)\t// Loads A TGA File Into Memory\n{\n\tGLuint i;\n\tGLubyte\n\t\tTGAuncompressedheader[12]={ 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0},\t// Uncompressed TGA Header\n\t\tTGAcompressedheader[12]={ 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0},\t// Uncompressed TGA Header\n\t\tactualHeader[12],\t// Used To Compare TGA Header\n\t\theader[6];\t\t// First 6 Useful Bytes From The Header\n\tGLuint bytesPerPixel,\t\t// Holds Number Of Bytes Per Pixel Used In The TGA File\n\t\timageSize,\t\t// Used To Store The Image Size When Setting Aside Ram\n\t\ttemp;\t\t\t// Temporary Variable\n\tlong w, h;\n\tlong rowSize, stepSize, bytesRead;\n\tGLubyte *rowP;\n\tint err;\n\tGLubyte rle;\n\tint b;\n\tlong row, rowLimit;\n\tGLubyte pixelData[4];\n\t\n\tFILE *file = fopen(filename, \"rb\");\t\t\t// Open The TGA File\n\terr = 0;\n\tif (file == NULL) err = 1;\t\t\t\t// Does File Even Exist?\n\telse if (fread(actualHeader, 1, sizeof(actualHeader), file) != sizeof(actualHeader)) err = 2; // Are There 12 Bytes To Read?\n\telse if (\n\t\t\t\t(memcmp(TGAuncompressedheader, actualHeader, sizeof(TGAuncompressedheader)) != 0) &&\n\t\t\t\t(memcmp(TGAcompressedheader, actualHeader, sizeof(TGAcompressedheader)) != 0)\n\t\t\t)\n\t\t\t\terr = 3; // Does The Header Match What We Want?\n\telse if (fread(header, 1, sizeof(header), file) != sizeof(header)) err = 4; // If So Read Next 6 Header Bytes\n\t\n\tif (err != 0)\n\t{\n\t\tswitch (err)\n\t\t{\n\t\t\tcase 1: printf(\"could not open file %s\\n\", filename); return false;break;\n\t\t\tcase 2: printf(\"could not read header of %s\\n\", filename); return false;break;\n\t\t\tcase 3: printf(\"unsupported format in %s\\n\", filename); return false;break;\n\t\t\tcase 4: printf(\"could not read file %s\\n\", filename); return false;break;\n\t\t}\n\t\t\n\t\tif(file == NULL)\t\t// Did The File Even Exist? *Added Jim Strong*\n\t\t\treturn false;\n\t\telse\n\t\t{\n\t\t\tfclose(file);\t\t// If Anything Failed, Close The File\n\t\t\treturn false;\n\t\t}\n\t}\n\ttexture->width  = header[1] * 256 + header[0];\t// Determine The TGA Width (highbyte*256+lowbyte)\n\ttexture->height = header[3] * 256 + header[2];\t// Determine The TGA Height (highbyte*256+lowbyte)\n\tif (texture->width <= 0 ||\t// Is The Width Less Than Or Equal To Zero\n\ttexture->height <= 0 ||\t\t// Is The Height Less Than Or Equal To Zero\n\t(header[4] != 24 && header[4] != 32))\t\t\t// Is The TGA 24 or 32 Bit?\n\t{\n\t\tfclose(file);\t\t// If Anything Failed, Close The File\n\t\treturn false;\n\t}\n\t\n\tw = 1;\n\twhile (w < texture->width) w = w << 1;\n\th = 1;\n\twhile (h < texture->height) h = h << 1;\n\ttexture->texWidth = (GLfloat)texture->width / w;\n\ttexture->texHeight = (GLfloat)texture->height / h;\n\t\n\ttexture->bpp = header[4];\t\t// Grab The TGA's Bits Per Pixel (24 or 32)\n\tbytesPerPixel = texture->bpp/8;\t\t// Divide By 8 To Get The Bytes Per Pixel\n\timageSize = w * h * bytesPerPixel;\t// Calculate The Memory Required For The TGA Data\n\trowSize\t= texture->width * bytesPerPixel;\t// Image memory per row\n\tstepSize = w * bytesPerPixel;\t\t// Memory per row\n\ttexture->imageData = (GLubyte *)calloc(1, imageSize);\n\tif (texture->imageData == NULL)\t\t\t\t// Does The Storage Memory Exist?\n\t{\n\t\tfclose(file);\n\t\treturn false;\n\t}\n\n\tif (actualHeader[2] == 2) // uncompressed\n\t{\n\t\trowP = &texture->imageData[0];\n\t\tfor (i = 0; i < texture->height; i++)\n\t\t{\n\t\t\tbytesRead = fread(rowP, 1, rowSize, file);\n\t\t\trowP += stepSize;\n\t\t\tif (bytesRead != rowSize)\n\t\t\t{\n\t\t\t\tfree(texture->imageData);\t// If So, Release The Image Data\n\t\t\t\tfclose(file);\t\t\t// Close The File\n\t\t\t\treturn false;\t\t\t// Return False\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{ // compressed\n\t\trow = 0 + (texture->height -1) * stepSize;\n\t\ti = row;\n\t\trowLimit = row + rowSize;\n\t\tdo\n\t\t{\n\t\t\tbytesRead = fread(&rle, 1, 1, file);\n\t\t\tif (rle < 128)\n\t\t\t{ // rle+1 raw pixels\n\t\t\t\tbytesRead = fread(&texture->imageData[i], 1, (rle+1)*bytesPerPixel, file);\n\t\t\t\ti += bytesRead;\n\t\t\t\tif (bytesRead == 0)\n\t\t\t\t\ti = imageSize;\n\t\t\t}\n\t\t\telse\n\t\t\t{ // range of rle-127 pixels with a color that follows\n\t\t\t\tbytesRead = fread(&pixelData, 1, bytesPerPixel, file);\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tfor (b = 0; b < bytesPerPixel; b++)\n\t\t\t\t\t\ttexture->imageData[i+b] = pixelData[b];\n\t\t\t\t\ti += bytesPerPixel;\n\t\t\t\t\trle = rle - 1;\n\t\t\t\t} while (rle > 127);\n\t\t\t}\n\t\t\tif (i >= rowLimit)\n\t\t\t{\n\t\t\t\trow = row - stepSize;\n\t\t\t\trowLimit = row + rowSize;\n\t\t\t\ti = row;\n\t\t\t}\n\t\t} while (i < imageSize);\n\t}\n\n\tfor (i = 0; i < (int)(imageSize); i += bytesPerPixel)\t// Loop Through The Image Data\n\t{\t\t// Swaps The 1st And 3rd Bytes ('R'ed and 'B'lue)\n\t\ttemp = texture->imageData[i];\t\t// Temporarily Store The Value At Image Data 'i'\n\t\ttexture->imageData[i] = texture->imageData[i + 2];\t// Set The 1st Byte To The Value Of The 3rd Byte\n\t\ttexture->imageData[i + 2] = temp;\t// Set The 3rd Byte To The Value In 'temp' (1st Byte Value)\n\t}\n\tfclose (file);\n\treturn true;\t\t\t\t// Texture Building Went Ok, Return True\n}\n\n\nbool LoadTGATexture(char *filename, TextureData *texture)\t// Loads A TGA File Into Memory and uploads to VRAM\n{\n\tbool result = LoadTGATextureData(filename, texture); // Loads A TGA File Into Memory\n\tif (!result)\n\t\treturn result;\n\t\n\tGLuint type = GL_RGBA;\t\t// Set The Default GL Mode To RBGA (32 BPP)\n\tint h, w;\n\n\tw = 1;\n\twhile (w < texture->width) w = w << 1;\n\th = 1;\n\twhile (h < texture->height) h = h << 1;\n\t\n\t// Build A Texture From The Data\n\tglGenTextures(1, &texture[0].texID);\t\t\t// Generate OpenGL texture IDs\n\tglBindTexture(GL_TEXTURE_2D, texture[0].texID);\t\t// Bind Our Texture\n\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\t// Linear Filtered\n//\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\t// Linear Filtered\n\tif (texture[0].bpp == 24)\t\t\t\t\t\t// Was The TGA 24 Bits?\n\t{\n\t\ttype=GL_RGB;\t\t\t// If So Set The 'type' To GL_RGB\n\t}\n//\tgluBuild2DMipmaps(GL_TEXTURE_2D, type, w, h, type, GL_UNSIGNED_BYTE, texture[0].imageData);\n\tglTexImage2D(GL_TEXTURE_2D, 0, type, w, h, 0, type, GL_UNSIGNED_BYTE, texture[0].imageData);\n\t\n\treturn result;\n}\n\nvoid LoadTGATextureSimple(char *filename, GLuint *tex) // If you really only need the texture object.\n{\n\tTextureData texture;\n\t\n\tif (LoadTGATexture(filename, &texture))\n\t{\n\t\tif(texture.imageData != NULL)\n\t\t\tfree(texture.imageData);\n\t\t*tex = texture.texID;\n\t}\n\telse\n\t\t*tex = 0;\n}\n\n\n// saves an array of pixels as a TGA image\nint tgaSave(char\t\t\t*filename, \n\t\t\t short int\t\twidth, \n\t\t\t short int\t\theight, \n\t\t\t unsigned char\tpixelDepth,\n\t\t\t unsigned char\t*imageData)\n{\n\tunsigned char cGarbage = 0, mode,aux;\n\tint i, w, ix;\n\tFILE *file;\n\tchar /*GLubyte*/ TGAuncompressedheader[12]={ 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0};\t// Uncompressed TGA Header\n\n// open file and check for errors\n\tfile = fopen(filename, \"rb\");\n\tif (file == NULL)\n\t\treturn(TGA_ERROR_FILE_OPEN);\n\n// compute image type: 2 for RGB(A), 3 for greyscale\n\tmode = pixelDepth / 8;\n\n// write the header\n\tfwrite(&TGAuncompressedheader, 12, 1, file);\n\tfwrite(&width, sizeof(short int), 1, file);\n\tfwrite(&height, sizeof(short int), 1, file);\n\tfwrite(&pixelDepth, sizeof(unsigned char), 1, file);\n\n\tfwrite(&cGarbage, sizeof(unsigned char), 1, file);\n\n// convert the image data from RGB(a) to BGR(A)\n\tif (mode >= 3)\n\tfor (i=0; i < width * height * mode ; i+= mode)\n\t{\n\t\taux = imageData[i];\n\t\timageData[i] = imageData[i+2];\n\t\timageData[i+2] = aux;\n\t}\n\n// save the image data\n\tw = 1;\n\twhile (w < width) w = w << 1;\t\n\t\n// Write one row at a time\n\tfor (i = 0; i < height; i++)\n\t{\n\t\tix = i * w * mode;\n\t\tfwrite(&imageData[ix], sizeof(unsigned char), width * mode, file);\n\t}\n\n\tfclose(file);\n// release the memory\n\tfree(imageData);\n\n\treturn(TGA_OK);\n}\n\nvoid SaveTGA(TextureData *tex, char *filename)\n{\n\ttgaSave(filename, tex->width, tex->height, \n\t\t\ttex->bpp, tex->imageData);\n}\n","// New version 120201:\n// Defaults to matrices \"by the book\". Can also be configured to the flipped\n// matrices that old OpenGL required (and we all hated).\n// This is freshly implemented, limited testing, so there can be bugs.\n// But it seems to work just fine on my tests with translation, rotations\n// and matrix multiplications.\n\n\n#include \"VectorUtils2.h\"\n\nchar transposed = 0;\n\n\tvoid CopyVector(Point3D *v, Point3D *dest)\n\t{\n\t\tdest->x = v->x;\n\t\tdest->y = v->y;\n\t\tdest->z = v->z;\n\t}\n\t\n\tvoid SetVector(GLfloat x, GLfloat y, GLfloat z, Point3D *v)\n\t{\n\t\tv->x = x;\n\t\tv->y = y;\n\t\tv->z = z;\n\t}\n\t\n\tvoid VectorSub(Point3D *a, Point3D *b, Point3D *result)\n\t{\n\t\tresult->x = a->x - b->x;\n\t\tresult->y = a->y - b->y;\n\t\tresult->z = a->z - b->z;\n\t}\n\t\n\tvoid VectorAdd(Point3D *a, Point3D *b, Point3D *result)\n\t{\n\t\tresult->x = a->x + b->x;\n\t\tresult->y = a->y + b->y;\n\t\tresult->z = a->z + b->z;\n\t}\n\t\n\tvoid CrossProduct(Point3D *a, Point3D *b, Point3D *result)\n\t{\n\t\tPoint3D temp;\n\t\t\n\t\ttemp.x = a->y*b->z - a->z*b->y;\n\t\ttemp.y = a->z*b->x - a->x*b->z;\n\t\ttemp.z = a->x*b->y - a->y*b->x;\n\t\t\n\t\tresult->x = temp.x;\n\t\tresult->y = temp.y;\n\t\tresult->z = temp.z;\n\t}\n\t\n\tGLfloat DotProduct(Point3D *a, Point3D *b)\n\t{\n\t\treturn a->x * b->x + a->y * b->y + a->z * b->z;\n\t}\n\t\n\tvoid ScalarMult(Point3D *a, GLfloat s, Point3D *result)\n\t{\n\t\tresult->x = a->x * s;\n\t\tresult->y = a->y * s;\n\t\tresult->z = a->z * s;\n\t}\n\t\n\tGLfloat Norm(Point3D *a)\n\t{\n\t\tGLfloat result;\n\t\t\n\t\tresult = sqrt(a->x * a->x + a->y * a->y + a->z * a->z);\n\t\treturn result;\n\t}\n\t\n\tvoid Normalize(Point3D *a)\n\t{\n\t\tGLfloat result;\n\t\t\n\t\tresult = sqrt(a->x * a->x + a->y * a->y + a->z * a->z);\n\t\ta->x = a->x / result;\n\t\ta->y = a->y / result;\n\t\ta->z = a->z / result;\n\t}\n\t\n\tvoid CalcNormalVector(Point3D *a, Point3D *b, Point3D *c, Point3D *result)\n\t{\n\t\tPoint3D ab, ac, n;\n\t\t\n\t\tVectorSub(a, b, &ab);\n\t\tVectorSub(a, c, &ac);\n\t\tCrossProduct(&ab, &ac, &n);\n\t\tScalarMult(&n, 1/Norm(&n), &n);\n\t\tresult->x = n.x;\n\t\tresult->y = n.y;\n\t\tresult->z = n.z;\n\t}\n\n\t// Delar v i vn (parallell med n) och vp (vinkelr�t). Kr�ver INTE att n �r normerad!\n\tvoid SplitVector(Point3D *v, Point3D *n, Point3D *vn, Point3D *vp)\n\t{\n\t\tGLfloat nlen;\n\t\tGLfloat nlen2;\n\t\t\n\t\tnlen = DotProduct(v, n);\n\t\tnlen2 = n->x*n->x+n->y*n->y+n->z*n->z; // l�ngen av n i kvadrat\n\t\tif (nlen2 == 0)\n\t\t{\n\t\t\tCopyVector(v, vp);\n\t\t\tSetVector(0, 0, 0, vn);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tScalarMult(n, nlen/nlen2, vn);\n\t\t\tVectorSub(v, vn, vp);\n\t\t}\n\t}\n\n// Matrisoperationer p� 4x4-matriser!\n// Alla matriser �r arrays av GLfloat!\n\n\tvoid IdentityMatrix(GLfloat *m)\n\t{\n\t\tint i;\n\t\t\n\t\tfor (i = 0; i <= 15; i++)\n\t\t\tm[i] = 0;\n\t\tfor (i = 0; i <= 3; i++)\n\t\t\tm[i * 5] = 1; // 0,5,10,15\n\t}\n\n\tvoid Rx(GLfloat a, GLfloat *m)\n\t{\n\t\tIdentityMatrix(m);\n\t\tm[5] = cos(a);\n\t\tif (transposed)\n\t\t\tm[9] = -sin(a);\n\t\telse\n\t\t\tm[9] = sin(a);\n\t\tm[6] = -m[9]; //sin(a);\n\t\tm[10] = m[5]; //cos(a);\n\t}\n\t\n\tvoid Ry(GLfloat a, GLfloat *m)\n\t{\n\t\tIdentityMatrix(m);\n\t\tm[0] = cos(a);\n\t\tif (transposed)\n\t\t\tm[8] = -sin(a);\n\t\telse\n\t\t\tm[8] = sin(a);\n\t\tm[2] = -m[8]; //sin(a);\n\t\tm[10] = m[0]; //cos(a);\n\t}\n\n\tvoid Rz(GLfloat a, GLfloat *m)\n\t{\n\t\tIdentityMatrix(m);\n\t\tm[0] = cos(a);\n\t\tif (transposed)\n\t\t\tm[4] = -sin(a);\n\t\telse\n\t\t\tm[4] = sin(a);\n\t\tm[1] = -m[4]; //sin(a);\n\t\tm[5] = m[0]; //cos(a);\n\t}\n\n\tvoid T(GLfloat tx, GLfloat ty, GLfloat tz, GLfloat *m)\n\t{\n\t\tIdentityMatrix(m);\n\t\tif (transposed)\n\t\t{\n\t\t\tm[12] = tx;\n\t\t\tm[13] = ty;\n\t\t\tm[14] = tz;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm[3] = tx;\n\t\t\tm[7] = ty;\n\t\t\tm[11] = tz;\n\t\t}\n\t}\n\n\tvoid S(GLfloat sx, GLfloat sy, GLfloat sz, GLfloat *m)\n\t{\n\t\tIdentityMatrix(m);\n\t\tm[0] = sx;\n\t\tm[5] = sy;\n\t\tm[10] = sz;\n\t}\n\n\tvoid Mult(/*GLfloat *dest,*/ GLfloat *a, GLfloat *b, GLfloat *dest) // m = a * b\n\t{\n\t\tGLfloat\tm[16];\n\t\t\n\t\tint x, y, i;\n\t\tfor (x = 0; x <= 3; x++)\n\t\t\tfor (y = 0; y <= 3; y++)\n\t\t\t\tif (transposed)\n\t\t\t\t\tm[x*4 + y] =\ta[y+4*0] * b[0+4*x] +\n\t\t\t\t\t\t\t\ta[y+4*1] * b[1+4*x] +\n\t\t\t\t\t\t\t\ta[y+4*2] * b[2+4*x] +\n\t\t\t\t\t\t\t\ta[y+4*3] * b[3+4*x];\n\t\t\t\telse\n\t\t\t\t\tm[y*4 + x] =\ta[y*4+0] * b[0*4+x] +\n\t\t\t\t\t\t\t\ta[y*4+1] * b[1*4+x] +\n\t\t\t\t\t\t\t\ta[y*4+2] * b[2*4+x] +\n\t\t\t\t\t\t\t\ta[y*4+3] * b[3*4+x];\n\t\tfor (i = 0; i <= 15; i++)\n\t\t\tdest[i] = m[i];\n\t}\n\t\t\n\t// Matris g�nger vektor\n\t// Vektorn 3D (ej 4D) g�r att man f�r fuska till homogena koordinaten\n\tvoid MatrixMultPoint3D(GLfloat *a, Point3D *b, Point3D *result) // result = a * b\n\t{\n\t\tPoint3D r;\n\t\t\n\t\tif (!transposed)\n\t\t{\n\t\t\tr.x = a[0]*b->x + a[1]*b->y + a[2]*b->z + a[3];\n\t\t\tr.y = a[4]*b->x + a[5]*b->y + a[6]*b->z + a[7];\n\t\t\tr.z = a[8]*b->x + a[9]*b->y + a[10]*b->z + a[11];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr.x = a[0]*b->x + a[4]*b->y + a[8]*b->z + a[12];\n\t\t\tr.y = a[1]*b->x + a[5]*b->y + a[9]*b->z + a[13];\n\t\t\tr.z = a[2]*b->x + a[6]*b->y + a[10]*b->z + a[14];\n\t\t//r.h = a[3]*b->x + a[7]*b->y + a[11]*b->z + a[15]*b->h;\n\t\t}\n\t\t\n\t\t*result = r;\n\t}\n\t\n\t\n\tvoid CopyMatrix(GLfloat *src, GLfloat *dest)\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= 15; i++)\n\t\t\tdest[i] = src[i];\n\t}\n\n\n// Added for lab 3\n\n\t// Orthonormalization of Matrix4D. Assumes rotation only, translation/projection ignored\n\tvoid OrthoNormalizeMatrix(GLfloat *R)\n\t{\n\t\tPoint3D x, y, z;\n\t\t\n\t\tif (transposed)\n\t\t{\n\t\t\tSetVector(R[0], R[1], R[2], &x);\n\t\t\tSetVector(R[4], R[5], R[6], &y);\n//\t\tSetVector(R[8], R[9], R[10], &z);\n\t\t\t// Kryssa fram ur varandra\n\t\t\t// Normera\n\t\t\tCrossProduct(&x, &y, &z);\n\t\t\tNormalize(&z);\n\t\t\tNormalize(&x);\n\t\t\tCrossProduct(&z, &x, &y);\n\t\t\tR[0] = x.x;\n\t\t\tR[1] = x.y;\n\t\t\tR[2] = x.z;\n\t\t\tR[4] = y.x;\n\t\t\tR[5] = y.y;\n\t\t\tR[6] = y.z;\n\t\t\tR[8] = z.x;\n\t\t\tR[9] = z.y;\n\t\t\tR[10] = z.z;\n\t\t\t\n\t\t\tR[3] = 0.0;\n\t\t\tR[7] = 0.0;\n\t\t\tR[11] = 0.0;\n\t\t\tR[12] = 0.0;\n\t\t\tR[13] = 0.0;\n\t\t\tR[14] = 0.0;\n\t\t\tR[15] = 1.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t// NOT TESTED\n\t\t\tSetVector(R[0], R[4], R[8], &x);\n\t\t\tSetVector(R[1], R[5], R[9], &y);\n//\t\tSetVector(R[2], R[6], R[10], &z);\n\t\t\t// Kryssa fram ur varandra\n\t\t\t// Normera\n\t\t\tCrossProduct(&x, &y, &z);\n\t\t\tNormalize(&z);\n\t\t\tNormalize(&x);\n\t\t\tCrossProduct(&z, &x, &y);\n\t\t\tR[0] = x.x;\n\t\t\tR[4] = x.y;\n\t\t\tR[8] = x.z;\n\t\t\tR[1] = y.x;\n\t\t\tR[5] = y.y;\n\t\t\tR[9] = y.z;\n\t\t\tR[2] = z.x;\n\t\t\tR[6] = z.y;\n\t\t\tR[10] = z.z;\n\t\t\t\n\t\t\tR[3] = 0.0;\n\t\t\tR[7] = 0.0;\n\t\t\tR[11] = 0.0;\n\t\t\tR[12] = 0.0;\n\t\t\tR[13] = 0.0;\n\t\t\tR[14] = 0.0;\n\t\t\tR[15] = 1.0;\n\t\t}\n\t}\n\t\n\t\n\t// Transponerar enbart rotationsdelen! Kopierar till ny matris.\n\tvoid Transpose(GLfloat *m, GLfloat *a)\n\t{\n\t\ta[0] = m[0]; a[4] = m[1]; a[8] = m[2];      a[12] = m[12];\n\t\ta[1] = m[4]; a[5] = m[5]; a[9] = m[6];      a[13] = m[13];\n\t\ta[2] = m[8]; a[6] = m[9]; a[10] = m[10];    a[14] = m[14];\n\t\t\n\t\ta[3] = m[3]; a[7] = m[7]; a[11] = m[11];    a[15] = m[15];\n\t}\n\t\n\n// Rotation kring godtycklig axel (enbart rotationen)\nvoid ArbRotate(Point3D *axis, GLfloat fi, GLfloat *m)\n{\n\tPoint3D x, y, z;\n\tGLfloat R[16], Rt[16], Raxel[16], RtRx[16];\n\t\n// Kolla ocks� om parallell med Z-axel!\n\tif (axis->x < 0.0000001) // Under n�gon tillr�ckligt liten gr�ns\n\tif (axis->x > -0.0000001)\n\tif (axis->y < 0.0000001)\n\tif (axis->y > -0.0000001){\n\t\tif (axis->z > 0)\n\t\t{\n\t\t\tRz(fi, m);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tRz(-fi, m);\n\t\t\treturn;\n\t\t}}\n\n\tx = *axis;\n\tNormalize(&x); // |x|\n\tSetVector(0,0,1, &z); // Temp z\n\tCrossProduct(&z, &x, &y);\n\tNormalize(&y); // y' = z^ x x'\n\tCrossProduct(&x, &y, &z); // z' = x x y\n\n\tif (transposed)\n\t{\n\t\tR[0] = x.x; R[4] = x.y; R[8] = x.z;  R[12] = 0.0;\n\t\tR[1] = y.x; R[5] = y.y; R[9] = y.z;  R[13] = 0.0;\n\t\tR[2] = z.x; R[6] = z.y; R[10] = z.z;  R[14] = 0.0;\n\t\t\n\t\tR[3] = 0.0; R[7] = 0.0; R[11] = 0.0;  R[15] = 1.0;\n\t}\n\telse\n\t{\n\t\tR[0] = x.x; R[1] = x.y; R[2] = x.z;  R[3] = 0.0;\n\t\tR[4] = y.x; R[5] = y.y; R[6] = y.z;  R[7] = 0.0;\n\t\tR[8] = z.x; R[9] = z.y; R[10] = z.z;  R[11] = 0.0;\n\t\t\n\t\tR[12] = 0.0; R[13] = 0.0; R[14] = 0.0;  R[15] = 1.0;\n\t}\n\t\n\tTranspose(R, Rt); // Transpose = Invert -> felet ej i Transpose, och det �r en ortonormal matris I MIGHT HAVE BROKENZ IT\n\t\n\tRx(fi, Raxel); // Rotate around x axis\n\t\n\t// m := Rt * Rx * R\n\tMult(Rt, Raxel, RtRx);\n\tMult(RtRx, R, m);\n}\n\n\n// KLART HIT\n\n\n// Inte testad mycket. Hoppas jag inte v�nt p� den.\nvoid CrossMatrix(Point3D *a, GLfloat *m) // Skapar matris f�r kryssprodukt\n{\n\tm[0] =    0; m[4] =-a->z; m[8] = a->y; m[12] = 0.0;\n\tm[1] = a->z; m[5] =    0; m[9] =-a->x; m[13] = 0.0;\n\tm[2] =-a->y; m[6] = a->x; m[10]=    0; m[14] = 0.0;\n\tm[3] =  0.0; m[7] =  0.0; m[11]=  0.0; m[15] = 0.0;\n\t// OBS! 0.0 i homogena koordinaten. D�rmed kan matrisen\n\t// inte anv�ndas generellt, men duger f�r matrisderivatan.\n}\n\nvoid MatrixAdd(GLfloat *a, GLfloat *b, GLfloat *dest)\n{\n\tint i;\n\tfor (i = 0; i < 16; i++)\n\t\tdest[i] = a[i] + b[i];\n}\n\nvoid CalcNormalMatrix(GLfloat *in, GLfloat *ut) // 3x3-invers o transpose\n{\n\tGLfloat normMatrix[9] = {\t0.0f,0.0f,0.0f,\n\t\t\t\t\t\t0.0f,0.0f,0.0f,\n\t\t\t\t\t\t0.0f,0.0f,0.0f };\n\n\tnormMatrix[0] = in[0];\n\tnormMatrix[1] = in[1];\n\tnormMatrix[2] = in[2];\n\tnormMatrix[3] = in[4];\n\tnormMatrix[4] = in[5];\n\tnormMatrix[5] = in[6];\n\tnormMatrix[6] = in[8];\n\tnormMatrix[7] = in[9];\n\tnormMatrix[8] = in[10];\n\n\tGLfloat mprim[9] = {normMatrix[4]*normMatrix[8]-normMatrix[5]*normMatrix[7],\n\t\t\t\t\t\tnormMatrix[2]*normMatrix[7]-normMatrix[1]*normMatrix[8],\n\t\t\t\t\t\tnormMatrix[1]*normMatrix[5]-normMatrix[2]*normMatrix[4], \n\t\t\t\t\t\tnormMatrix[5]*normMatrix[6]-normMatrix[3]*normMatrix[8],\n\t\t\t\t\t\tnormMatrix[0]*normMatrix[8]-normMatrix[2]*normMatrix[6],\n\t\t\t\t\t\tnormMatrix[2]*normMatrix[3]-normMatrix[0]*normMatrix[5],\n\t\t\t\t\t\tnormMatrix[3]*normMatrix[7]-normMatrix[4]*normMatrix[6],\n\t\t\t\t\t\tnormMatrix[1]*normMatrix[6]-normMatrix[0]*normMatrix[7],\n\t\t\t\t\t\tnormMatrix[0]*normMatrix[4]-normMatrix[1]*normMatrix[3]};\n\n\tGLfloat det = normMatrix[0]*(normMatrix[4]*normMatrix[8]-normMatrix[5]*normMatrix[7])-normMatrix[1]*(normMatrix[3]*normMatrix[8]-normMatrix[5]*normMatrix[6])+normMatrix[2]*(normMatrix[3]*normMatrix[7]-normMatrix[4]*normMatrix[6]);\n\n\n\n\nif(det==0) {\n\tfor(int i=0;i<9;i++) {\n\t\tut[i]=normMatrix[i];\n\t}\n}\nelse{\n\n\n\tut[0] = (1/det)*mprim[0];\n\tut[1] = (1/det)*mprim[3];\n\tut[2] = (1/det)*mprim[6];\n\tut[3] = (1/det)*mprim[1];\n\tut[4] = (1/det)*mprim[4];\n\tut[5] = (1/det)*mprim[7];\n\tut[6] = (1/det)*mprim[2];\n\tut[7] = (1/det)*mprim[5];\n\tut[8] = (1/det)*mprim[8];\n}\n\n\n}\n\n\nvoid SetTransposed(char t)\n{\n\ttransposed = t;\n}\n"]}